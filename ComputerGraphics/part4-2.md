# Computer Graphics

# Part 4-2 - Pixel and Filter

#### 2024.10.25.(금)

### Point Processing vs Image Filtering

- Point Operation: point processing

- Neighborhood Operation: "filtering"

### [디지털 영상처리 - Filter 편 #1](https://secmem.tistory.com/520)

이미지 데이터에 연산을 하고 목적에 따른 결과를 얻는 것을 Filtering 이라고 하는데, 신호처리에서 사용되는 주파수 관련용어와 같은 단어이다.

1. Linear Filtering

가장 기본적인 필터로, 주로 노이즈를 제거하기 위한 용도로 쓰인다. 여기서 노이즈란 다음과 같은 파형으로 생각할 수 있다.

1,3 번은 주위의 값들과 비슷한 값을 유지하고 있는 반면 2번은 주위의 값보다 튀는 값을 갖고 있다. 이렇게 주변보다 튀는 값을 가진 2번 부분을 노이즈라고 볼 수 있다. 그럼 이런 노이즈를 어떻게 하면 없앨 수 있을까? 영상처리에서 가장 간단히 사용하는 방법은 다음과 같은 Box filter 를 사용하는 것이다. (아래와 같은 행렬형태의 화소 그룹을 box filter 혹은 마스크(mask), 커널(kernel), 윈도우(window) 등 다양한 이름으로 부른다. 이 글에서는 편의상 box filter를 사용한다.)

Box filter는 주로 3x3 형태이며 가운데 값을 정하기 위해 주위의 값을 이용하는 것으로 각 숫자는 대부분 원본 데이터에 곱해지는 수를 의미한다. 3x3 형태 말고도 5x5, 7x7 등의 box도 사용 가능하지만 연산량이 급격히 늘어나기 때문에 주로 3x3을 사용한다.

이제 몇가지 선형 필터의 종류에 대해 알아보자.

1. 평균값 필터

평균값 필터는 다음과 같은 box filter를 사용하며, 가운데 픽셀값을 얻기 위해 주위 픽셀의 평균값을 이용하는 것을 뜻한다.

2. 중간값 필터

중간값 필터는 이웃픽셀의 값들 중 중간값을 선택하는 것이다.

이웃 픽셀에 있는 값들을 모두 정렬한 후 가운데 값을 선택해 빨간색 픽셀을 대체시키는 것이다.

3. 가우시안 필터

왼쪽과 같은 필터는 가운데 픽셀과 이웃픽셀의 차이가 큰 모양을 하고 있다. 이 필터를 이미지에 적용시킬 경우 결과 이미지가 마치 블럭처럼 보이게 된다. 이를 해결하려면 오른쪽과 같은 필터를 사용하면 되는데, 이 필터가 가우시안 필터이다.

이 외에도 노이즈를 제거하는 방법으로는 모폴로지 연산(침식, 팽창 등)이 있으며 노이즈 제거로 인해 뿌옇게 된 영상을 선명하게 만드는 언샤프(Unsharp) 연산도 있다. 이 외에도 다양한 선형 필터가 존재하며 필요에 따라 사용할 수 있다.

### [영상(Image)의 합성곱(Convolution)의 이해](https://velog.io/@lighthouse97/%EC%98%81%EC%83%81Image%EC%9D%98-%ED%95%A9%EC%84%B1%EA%B3%B1Convolution%EC%9D%98-%EC%9D%B4%ED%95%B4)

### 1. 이미지 데이터와 CNN (Convolution Neural Network)

DNN (Deep Neural Network)는 주로 1차원 형태의 데이터를 사용한다. 따라서 그림이나 이미지와 같은 2차원 형태의 데이터를 사용할 때는 1차원 형태로 flatten 시켜야 한다. (완전 연결 계층, fully connected layer)

flatten을 시키는 완전 연결 계층은 크게 2가지의 문제점이 발생한다.

1. 이는 원본 이미지 데이터의 형상을 완전히 무시하게 된다.
2. 추상화 과정 없이 바로 연산과정에 넘어가버리므로 학습시간과 능률 측면에서 효율성이 떨어진다.
   CNN (Convolution Neural Network)은 이러한 문제점을 해결하기 위해 도입된 방법이다.
   CNN (Convolution Neural Network)은 완전 연결 계층과 달리 2차원 형태의 배열을 그대로 사용할 수 있다.

### 2. 합성곱 (Convolution) 연산을 통한 이미지 데이터 필터링 (filtering)

> 2.1 이미지 분석

CNN은 특성상, 음성이나 이미지에서의 특징 추출에서 적극적으로 활용이 된다. 이는 '커널(Kernel)'이라는 필터를 이용하기 때문인데, 직접 CNN을 이용하여 이미지를 필터링 하여 보자.

위와 같이 2차원 평면에 그림이 있다. 이제 이를 CNN 모델을 이용하여 특징을 추출해보자.

단순히 이미지를 이용하여 특징 추출은 불가능하기 때문에 이를 데이터로 바꾸어준다. 이를 픽셀 (Pixel) 이라고 부르는데, 원본 이미지의 각 픽셀은 입력변수 또는 특성이 된다. 색깔이 있는 부분은 0으로, 색깔이 회색인 부분은 3으로 표시를 하였다.

> 필터(filter) 또는 커널(kernel)

이제 이 커널(kernel)이라는 필터(filter)를 이용하여 이미지를 필터링을 한다.
커널을 사용해 원본 이미지에 컨볼루션(convolution)을 취하면 필터의 특성에 맞게 강조된 이미지를 얻을 수 있다. 따라서 커널에 있는 값들은 사용자가 임의로 지정하는 것이다. 필자는 위의 그림과 같이 필터의 값들을 설정하였다.

> Stride(보폭)

필터링은 필터를 이미지에 놓고 움직이면서 한다. 이때 필터가 한번에 움직이는 거리를 보폭, 흔히 스트라이드(stride)라고 부른다. 커널이 한 칸씩 움직이면 스트라이드 값은 1이 되고, 두 칸씩 움직이면 2가 된다.
예를 들어 원본 이미지의 크기가 m x m이고, 필터 커널의 크기가 n x n, 스트라이드의 크기를 s라고 하면, 필터링을 통해 얻은 이미지는 (m-n)/s+1x(m-n)/s+1의 크기가 된다.

### [Edge Detection Filters](https://velog.io/@choonsik_mom/Edge-Detection-Filters)

### Edge란?

이미지에서 밝기 또는 색상이 급격하게 변하는 부분. 따라서 엣지를 찾는 가장 간단한 방법은 이미지를 "미분"하여 `밝기(intensity)의 변화율(gradient)`을 확인하는 것이다. gradient는 방향과 크기를 갖는 벡터(vector)로, 밝기가 변하는 방향(엣지의 방향)과 그 정도를 나타낸다.

이미지에서 엣지를 찾는 것은 컴퓨터 비전, 이미지 처리 분야에서 아주 중요하고 기초적인 단계라고 할 수 있다.

### 1. Laplacian filter

2차 미분을 사용하여 이미지의 경계를 검출한다.

라플라시안 필터는 주로 다음과 같은 형태이다.

L = [0 1 0] L = [0 1 0]
[1 -4 1] 또는 [1 -8 1]
[0 1 0] [0 1 0]

장점: 빠른 연산, 모든 방향 엣지를 잘 감지
단점: 노이즈에 매우 민감함

### 2. Sobel filter

x축 방향, y축 방햐의 1차 미분(gradient)를 계산하여 이미지의 경계를 검출한다. Gaussian smoothing과 미분을 결합하여 노이즈에 강하다. (중간 행 또는 열이 더 큰 가중치를 가짐 -> 가우시안 스무딩과 유사한 효과)

소벨 필터는 다음과 같은 형태이다.

- x축 방향 소벨 필터

Gx = [-1 0 +1]
[-2 0 +2]
[-1 0 +1]

- y축 방향 소벨 필터

Gy = [-1 -2 -1]
[0 0 0]
[+1 +2 +1]

그래디언트 크기 (gradient magnitude): √Gx^2 + Gy^2

그래디언트 방향 (gradient direction): arctan(Gy/Gx)

장점: Laplacian에 비해 노이즈에 강하며, 수평/수직 방향 엣지를 잘 감지

단점: 대각선 방향 엣지 검출에 약함

> 커널 계산 방법

다음과 같은 3x3 픽셀 이미지가 있다고 하자.

f = [1 2 3]
[1 2 3]
[1 2 3]

각 위치에서 커널과 이미지의 해당 픽셀 부분을 곱한 후 결과를 모두 더한다.

그러면 x축 방향 소벨 필터를 적용한다고 할 때, Gx = [-1 0 +1]
[-2 0 +2]
[-1 0 +1] 이므로

### 3. Scharr filter

sobel filter와 마찬가지로 x축, y축 방향 미분을 계산한다.

- x축 방향 슈마르 필터

Gx = [-3 0 +3]
[-10 0 +10]
[-3 0 +3]

- y축 방향 슈마르 필터

Gy = [-3 -10 -3]
[0 0 0]
[-3 +10 +3]

장점: Sobel filter와 유사하나, 더 정확한 gradient 계산 제공 (커널의 가중치가 edge direction에 대한 정확한 정보를 포착하는 데 더 적합하게 설계) -> 고해상도 이미지에서 미세한 엣지를 정확히 검출하고자 할 때 사용

단점: Sobel filter에 비해 계산 비용이 높음

sobel filter와 유사하다. (커널 값 차이)

- x축 방향 프리윗 필터

Gx = [+1 0 -1]
[+1 0 -1]
[+1 0 -1]

- y축 방향 프리윗 필터

Gy = [+1 +1 +1]
[0 0 0]
[-1 -1 -1]

### 4. Roberts cross filter

대각선 방향 엣지에 민감하며, 2x2 커널을 사용하고 연산 속도가 빠르다.

R = [+1 0]
[+0 -1] 또는 R = [0 +1]
[-1 0]

### 5. Canny Edge

sobel filter와 NMS(Non-Maximum Supression)을 사용하여 더 선명한 엣지를 검출한다.

Gaussian Filter -> gradient 계산(sobel filter 사용) -> Non-Maximum Suppression -> Double Thresholding -> Hysteresis

`Non-Maximum Suppression`: 엣지가 아닌 픽셀을 제거한다. 각 픽셀에서 그래디언트 방향을 따라 그래디언트 크기가 local maximum 값인지 확인한다. local maximum이 아니면 엣지가 아니라고 판단하고 제거한다.

`Double Thresholding`: 강한 엣지와 약한 엣지 구분을 위해 두 개의 임계값을 설정한다. 강한 엣지는 높은 임계값보다 큰 그래디언트를 가진 픽셀, 약한 엣지는 두 임계값 사이의 그래디언트를 가진 픽셀이다.

`Hysteresis`: 약한 엣지 중 강한 엣지와 연결된 픽셀만 엣지로 간주한다. 이를 통해 false edge를 제거한다.

### 이미지 이진화(Binarization)

`이미지 이진화(Binarization)`는 `이미지 분리(Image Segmentatioin)`를 하는 가장 간단한 방법으로 이미지 내의 물체와 배경을 0과 1, 또는 그 반대로, 두 값만으로 픽셀값을 재설정하는 것이다. 이는 3채널의 RGB값을 가진 이미지가 아닌 1채널을 가지고 있는 이진화된 이미지 데이터에만 적용 가능하다. 즉, 픽셀 값을 0~255까지 가진 흑백 사진으로 변경하는 것이다. 이 이진화 작업을 수행한 후 `Thresholding`을 통해 `임계값(Thresh)` 기준 이상의 값을 255, 미만의 값은 0으로 바꾸는 것이 가능하다.

### [Image Thresholding(이미지 이진화)](https://gimoonnam.github.io/imageprocessing/imageSegmentation/)

### Image Thresholding

이번 포스팅에선 `이미지 이진화(image binarization)` 대해서 공부해 보도록 한다.

`이미지 이진화`는 `이미지 분리(image segmentation)`을 하는 가장 간단한 방법으로 이미지 내의 물체와 배경을 0과 1, 또는 그 반대로, 두 값만으로 픽셀값을 재설정하는 것이다.

이 방법은 픽셀값이 0~255 사이의 값을 가지는 흑백 이미지에만 적용할 수 있다.

픽셀값을 0과 1로 바꾸는 것은 thresh라는 임계값을 기준으로 정해진다.

이 값을 수동으로 주는 것이 기본적인 `image thresholding`이며, 자동으로 알고리즘 내에서 정해지도록 하는 방법 중 가장 많이 사용되는 것은 `Otsu's method`이다.

### Simple image thresholding

`image thresholding`은 가장 단순하고 간단한 `image segmentation` 방법이다.

이것을 위해서 분리하는 영역과 배경의 픽셀값을 구분한다. 이것을 이라고 하며, 두 영역을 구분하는 픽셀값을 찾는 것을 뜻한다. 대표적으로 `Otsu's` 방법이 있다.
