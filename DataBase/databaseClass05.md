# Database Class 05

## 정규화

#### 2023.12.05.(화)

### 논리적 데이터베이스 설계

- ER 스키마 -> 관계 스키마로 사상

- 효율적인 데이터베이스 스키마 구축
  - 키, 무결성
  - 이상 현상
  - 함수적 종속성
  - 정규화 (테이블을 분해하는 과정)

### 1. 정규화와 이상 현상

- 데이터베이스 설계(database design)

  - 대량의 데이터를 데이터베이스 안에 어떻게 조직하여 구성하느냐는 중요한 문제
  - 현실 세계를 정확하고 자연스럽게 반영할 수 있도록 데이터베이스의 논리적 구조를 결정
  - 전체 데이터베이스에 대한 통합된 하나의 스키마(schema)를 정의

- 이상 현상

  - 잘못된 스키마 정의는 원하지 않는 여러 이상 현상을 발생시킴
    - SELECT 문으로 검색할 경우는 아무런 이상 현상이 발생하지 않음
    - INSERT, UPDATE, DELETE 문으로 데이터를 변경할 때는 3가지 이상 현상이 발생

- 정규화
  - 잘못된 스키마 정의를 바로 잡는 데이터베이스 설계 방법

### 1.2 이상(anomaly) 현상

1. 필요한 속성 값을 추가하다 보면 중복이 발생: 설계 오류
2. 데이터 중복으로 인해 릴레이션 조작 시 예상하지 못한 곤란한 현상이 발생
3. 이상 현상은 속성들 간에 존재하는 여러 종류의 종속 관계를 하나의 릴레이션으로 표현할 때 발생

### 1.2 이상 현상

1. 삽입 이상(insertion anomaly)

- 데이터를 삽입할 때 입력할 수 없는 상황이 발생
- 복합키인 경우, null 값이 발생하는 상황이 발생(개체 무결성 위배)

2. 갱신 이상(update anomaly)

- 002 학생이 기계과를 건축과로 수정할 때를 가정, 건축과와 기계과라는 데이터 불일치 발생
- 중복된 속성 값 중 일부가 수정되지 않을 경우 데이터 불일치가 발생할 수 있는 상황

3. 삭제 이상(deletion anomaly)

- 001 학번 학생이 C001을 수강 취소할 때 C001을 삭제하기 위해 학번, 학과 정보가 발생
- 삭제할 때 원하지 않는 유용한 데이터까지 함께 삭제되어 데이터 손실이 발생할 수 있는 상황

### 1.3 정규화의 개념

- 이상현상 발생 원인

  - 속성 사이의 많은 연관 관계를 무리하게 하나의 릴레이션으로 표현할 때 발생
    - 이를 방지하려면 속성 사이의 연관 관계 즉, 종속성(dependency)을 분석하여 하나의 릴레이션에는 하나의 종속성만 표현되도록 릴레이션을 분해하면 됨
  - 기본적으로 연관성이 높은 속성들을 하나의 릴레이션으로 구성하는 것이 바람직

- 정규화(normalization)
  - 데이터 이상 방지를 위해 중복을 감소시키는 구조로 단계적 규칙에 따라 릴레이션을 분해하는 과정
  - 잘못된 설계를 바로 잡는 과정

### 2. 함수 종속성

- 함수 종속성의 정의

  - 함수 종속성(FD: Functional Dependency)
    - 같은 릴레이션 안의 속성 값이 함수적으로 다른 속성 값을 결정하는 종속 관계
    - X -> Y로 표현 (X이면 Y이다. )
    - X는 결정자(Determinant), Y는 종속자(Dependent)
    - 학번 -> 김연아는 함수 종속, but 김연아 -> 학번은 함수 종속이 아님

- 함수 종속성(FD: Functional Dependency)
  - 같은 릴레이션 안에 포함된 속성 사이의 연관성을 분석할 수 있는 척도
  - '속성1 -> 속성2'로 표기
    - 어떤 속성2의 값이 다른 속성1의 값에 의해 결정되는 함수 종속 관계
    - 속성1은 속성2를 결정하는 결정자(determinant), 속성2는 속성1에 종속된 종속자(dependent)

### 2.2 함수 종속 다이아그램

- 함수 종속 다이아그램(FD diagram)

  - 하나의 릴레이션을 구성하는 속성들 간의 복잡한 함수 관계를 이해하기 쉽도록 표현한 그림
  - 릴레이션 속성은 사각형으로, 속성 간의 함수 종속성은 화살표로 표기

- '학생\_1' 릴레이션의 모든 함수 종속성을 함수 종속 다이아그램으로 표현

![database01](/assets/images/2023-12-05/database01.jpeg)

### 완전 함수 종속과 부분 함수 종속성

- 기본키가 복합키로 구성되어 있을 때, A(a,b,c,d,e,f)

  - 단일 속성 값으로 기본키가 구성되어 있을 때는 부분 함수 종속을 따질 필요가 없음
  - 학번이 과목코드를 결정? 학번이 성적을 결정? 학번이 학과를 결정?
  - (학번, 과목코드) 성적을 결정?

- 완전 함수 종속(full functional dependency)

- 부분 함수 종속(partial functional dependency)
  - 부분 함수 종속을 제거

![database02](/assets/images/2023-12-05/database02.jpeg)

### 완전 함수 종속과 부분 함수 종속성

- 이행적 함수 종속(3정규형 만족을 못함)

  - A -> B -> C
  - 결국, A -> C인 경우, 이행적 함수 종속
  - 학생이란 릴레이션의 구성(학번, 이름, 주민등록번호)
    - 학번 -> 주민등록번호 -> 이름
    - 이행적 함수 종속 성립
    - 학번, 주민등록번호로 구성, 주민등록번호, 이름으로 구성된 테이블로 분리

- 다치종속(MVD, Multi Value Dependent)

  - 다치 종속은 A ->-> B, A에 해당하는 B 값이 여러 개(집합으로 나올 때)일 때

- 조인종속

### 함수 종속 다이아그램의 예

- 함수 종속 다이아그램의 예(수강\_1)

![database03](/assets/images/2023-12-05/database03.jpeg)

### 정규화의 개념

- 정규화 과정에서 이상 문제를 해결하려면 연관성이 높은 속성들로만 릴레이션을 구성해야 함
  - 릴레이션 속성 사이의 연관성을 평가하기 위한 척도가 필요 -> 함수 종속성

![database04](/assets/images/2023-12-05/database04.jpeg)

### 3. 기본 정규형

정규형의 종류

![database05](/assets/images/2023-12-05/database05.jpeg)

- 정규형(NF: Normal Form)

  - 정규화 과정에서 릴레이션이 만족해야 하는 특정한 함수 종속성의 충족 조건
    - 특정 정규형이 요구하는 충족 조건을 릴레이션이 만족하면 해당 수준의 정규형을 충족함을 의미함
  - 제3정규형 이상의 정규형을 충족하면 충분한 정규화가 이루어졌다고 봄
    - 보통 제3정규형 또는 보이스코드 정규형까지만 정규화를 진행

- ER 스키마 -> 관계형 스키마로 매핑

- 비정규 릴레이션 -> 정규화된 릴레이션

  - 삽입, 삭제, 갱신 이상을 최소화

- 정규화의 목적

  - 데이터 구조의 안정성을 최대화
  - 중복을 배제하여 삽입, 삭제, 갱신 이상 발생을 방지
  - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임
  - 효과적인 검색 알고리즘을 생성

- 효율적인 데이터베이스 구축을 위해...

- Every entity in your database needs to have a single theme. (Edgar Codd)

- ERD
  - 필요한 속성들을 모두 포함
  - 필요없는 속성도 포함될 가능성 존재
  - 하나의 주제에 관계 있는 속성들로 구성

![database06](/assets/images/2023-12-05/database06.jpeg)

### 3.2 제1 정규형

- 제1정규형 정의

```
제1정규형(1NF): 어떤 릴레이션 R에 속한 모든 속성의 도메인이 원자 값(atomic value)만을 갖는다면 제1정규형(First Normal Form)에 속한다.
```

- 열에는 순서가 없다, 행에는 순서가 없다, 중복되는 열이 없다. 모든 행은 규칙적이다. 모든 열과 행의 중복지점에는 (열과 행의) 해당되는 분야에서 한 개의 값(single value)을 갖는다.

- 정규화 대상인 릴레이션이 관계형 데이터 모델의 기본 원칙을 따르기만 한다면 당연히 제1정규형에 속함.

```
학생_2(학번, 학생이름, 주소, {전화번호}, 성별)           제1정규형(x)
학생_3(학번, 학생이름, 주소, 집전화번호, 휴대폰번호, 성별)  제1정규형(o)
```

### 제1 정규형의 문제점

- (1-1) 삽입 이상
  - 과목번호 'c006'인 과목의 개설학과가 '통계'학과라는 사실만 따로 삽입할 수가 없음
- (1-2) 수정 이상
  - 컴퓨터학과의 학과장이 '박유찬'에서 '홍길동'으로 변경될 경우, 과목개설학과 '컴퓨터'인 모든 튜플을 찾아 '학과장' 속성 값을 한꺼번에 '홍길동'으로 변경해야 함
- (1-3) 삭제 이상
  - 만약, 학번 's002' 학생이 과목번호 'c002' 과목 수강을 취소하여 이 튜플을 삭제하면 'c002' 과목의 개설학과가 '경영' 학과이고 학과장이 '김철수'라는 원하지 않은 정보까지 데이터베이스에서 함께 삭제됨

### 제1정규형의 문제점 해결

![database07](/assets/images/2023-12-05/database07.jpeg)

### 무손실 분해

- 무손실 분해(nonloss decomposition)

  - 정규화 과정에서 릴레이션 분해는 어떤 정보도 손실되지 않게 동등한 릴레이션들로 분해해야 함
  - 정보 손실 없이 프로젝트(project) 연산으로 무손실 분해된 릴레이션은 자연 조인(natural join) 연산에 의해 다시 분해 이전의 릴레이션으로 복원이 가능
  - 복원이 불가능하면 잘못된 분해이며 이는 올바른 정규화가 아님

- 결정자와 결정자에 종속되는 속성들을 함께 떼어 내어 새로운 릴레이션을 생성할 때 결정자를 분할 전의 릴레이션에도 공통 속성으로 남겨두어야 함
  - 결정자가 이후 외래키로써 분해된 릴레이션 사이의 연관성을 유지할 수 있음

### 3.3 제2정규형

- 제2정규형 정의

```
제2정규형(2NF): 어떤 릴레이션 R이 제1정규형이고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수 종속이면 제2정규형(Second Normal Form)에 속한다.
```

- 제2정규형은 제1정규형을 충족하는 릴레이션의 기본키가 복합 속성일 때, 기본키의 일부 속성이 결정자인지를 검사함
- 만약 기본키가 단일 속성이면, 모든 속성이 완전 함수 종속이므로 검사할 필요가 없이 제2정규형에 속함

```
학생_3(학번, 학생이름, 주소, 집전화번호, 휴대폰번호, 성별)   제2정규형(o)
수강_2(학번, 과목번호, 학점, 학년, 과목개설학과, 학과장)    제2정규형(x)
수강_3(학번, 과목번호, 학점)  제2정규형(o)
학생_4(학번, 학년)  제2정규형(o)
과목_1(과목번호, 과목개설학과, 학과장)  제2정규형(o)
```

### 제2정규형의 문제점

![database08](/assets/images/2023-12-05/database08.jpeg)

- (2-1) 삽입 이상

  - 과목개설학과인 '통계'학과의 학과장이 '홍장미'라는 사실만 따로 삽입할 수가 없음

- (2-2) 수정 이상

  - 컴퓨터학과의 학과장이 '박유찬'에서 '홍길동'으로 변경될 경우, 여전히 과목개설학과 '컴퓨터'인 모든 튜플을 찾아 '학과장' 속성 값을 한꺼번에 '홍길동'으로 변경해야 함

- (2-3) 삭제 이상
  - 과목번호 'c002'의 등록을 취소하여 이 튜플을 삭제하면 '경영'학과의 학과장이 '김철수'라는 원하지 않은 정보까지 함께 삭제됨

### 제2정규형의 문제점 해결

- 제2정규형을 충족하는 '과목\_1' 릴레이션에 삽입(2-1), 수정(2-2), 삭제(2-3) 이상이 발생하는 이유

  - 아직도 둘 이상의 의미적 연관성을 하나의 릴레이션으로 함께 표현했기 때문

- 이행적 함수 종속성(transitive functional dependency)
  - 기본키에 속하지 않은 일반 속성 값이 기본키에 속하지 않은 또 다른 일반 속성 값을 결정함
  - 해결방법: 이행적 종속 관계를 끊어 두 종속 관계를 각기 다른 릴레이션에 표현 즉, 2개의 릴레이션으로 분해함

![database09](/assets/images/2023-12-05/database09.jpeg)

### 3.4 제3정규형

- 제3정규형 정의

```
제3정규형(3NF): 어떤 릴레이션 R이 제2정규형이고 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아니면, 제3정규형(Third Normal Form)에 속한다.
```

- 제3정규형은 제2정규형을 충족하는 릴레이션의 기본키가 아닌 일반 속성이 결정자인지를 검사
- 일반 속성이 기본키 속성이 아닌 일반 속성에 종속적일 때 제3정규형에 위배됨

```
수강_3 (학번, 과목번호, 학점)  제3정규형 (o)
학생_4 (학번, 학년)  제3정규형 (o)
과목_1 (과목번호, 과목개설학과, 학과장)  제3정규형 (x)
과목_2 (과목번호, 과목개설학과)  제3정규형 (o)
과목_3 (과목개설학과, 학과장)  제3정규형 (o)
```

### 제3정규형의 문제점

![database10](/assets/images/2023-12-05/database10.jpeg)

- (3-1) 삽입 이상

  - 과목번호 'c004'의 강의담당교수가 'p005'이라는 사실만 따로 삽입할 수는 없음

- (3-2) 수정 이상

  - 강의담당교수 'p001'의 담당 과목번호가 'c005'로 변경될 경우, 'p001'과 관련된 모든 튜플을 찾아 '과목번호' 속성 값을 한꺼번에 'c005'로 변경해야 함

- (3-3) 삭제 이상
  - 학번 's002'인 학생이 교과번호 'c002'의 수강을 취소하여 이 튜플을 삭제하면 'p002' 교수가 'c002' 과목을 강의한다는 정보까지 함께 삭제됨

### 제3정규형의 문제점 해결

- 제3정규형을 충족하는 '수강\_4' 릴레이션에 삽입(3-1), 수정(3-2), 삭제(3-3) 이상이 발생

  - 원인: 기본키가 아닌 속성이 기본키 일부 속성의 결정자가 되기 때문

- 이러한 문제를 해결하려면 기본키가 아닌 결정자를 분리하여 2개의 릴레이션으로 분해

![database11](/assets/images/2023-12-05/database11.jpeg)

![database12](/assets/images/2023-12-05/database12.jpeg)

![database13](/assets/images/2023-12-05/database13.jpeg)

### 3.5 보이스코드 정규형

- 보이스코드 정규형(BCNF: Boyce Codd Normal Form)의 정의
  - 복잡한 식별자 관계에 의한 문제를 해결하기 위해 제3정규형을 보완
  - "강한 제3정규형(strong 3NF)" 이라고도 함

```
보이스코드 정규형(BCNF): 릴레이션 R의 모든 결정자(determinant)가 후보키(candidate key)이면 릴레이션 R은 보이스코드 정규형에 속한다.
```

![database14](/assets/images/2023-12-05/database14.jpeg)

C가 A 또는 B의 결정자가 되는 경우,

- 후보키는 (A, B)
- 후보키가 아닌 C가 A 또는 B를 결정하면 안됨

![database15](/assets/images/2023-12-05/database15.jpeg)

### 3.6 정규화의 적용

- 정규화
  - 릴레이션을 정보 표현 측면에서 동등하면서도 중복을 감소시키는 더욱 작은 릴레이션들로 무손실 분해함으로써 이상 현상을 제거하는 데이터베이스 설계의 한 방법

![database16](/assets/images/2023-12-05/database16.jpeg)

### 반정규화

- 반정규화(de-normalization)
  - 정규화의 반대 개념, '역정규화'
    - 정규화와는 반대로 보다 낮은 수준의 정규형으로 릴레이션을 통합
    - 성능 저하가 문제될 경우 분해된 릴레이션을 역으로 통합, 성능을 향상시키는 설계 방법
  - 높은 정규형을 만족하는 릴레이션 스키마가 반드시 최적이라고 할 수는 없음
    - 정규화는 데이터의 정합성과 무결성이 강화되는 장점이 있지만 반대로 릴레이션 수가 과다하게 늘어나 SQL 문장이 복잡해지고 조인 연산 등으로 실행 시간이 오래 걸릴 수도 있기 때문
    - 자주 또 다량으로 조회되는 데이터에 대해서는 역으로 데이터 중복을 허용하는 반정규화 수행 가능
  - 반정규화는 다음 과정을 포함
    - 릴레이션들을 병합
    - 통계 \* 이력 릴레이션을 추가
    - 여러 릴레이션에 같은 속성을 중복하여 추가
    - 총계 \* 평균 같은 파생 속성을 추가
  - 반정규화는 데이터베이스 설계의 최종 단계에서 신중하게 고려
