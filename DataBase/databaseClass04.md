# Database Class 04

## 관계 대수

#### 2023.10.20.(금)

### 1. 관계 대수 연산

- 관계 대수 (relational algebra)
  = 릴레이션을 내부적으로 처리하기 위한 연산(operation)들의 집합

  - 코드 (Codd)가 정의
  - 관계형 데이터 모델의 이론적 언어로써 SQL 데이터베이스 언어의 이론적 토대 제공
    = 릴레이션에 적용되는 여러 연산들을 포함
  - 모든 연산의 적용 대상도 릴레이션이고 연산 결과 또한 릴레이션
  - 한 개 이상의 입력 릴레이션으로부터 하나의 새로운 결과 릴레이션을 생성

- 관계 대수 연산의 종류

![database1](/assets/images/2023-10-20/database1.png)

### 1.1 집합 연산

- 집합 연산 (set operation)

  - 릴레이션을 튜플 집합 또는 속성 집합으로 간주하여 이르르 처리하는 연산 그룹
  - 일반적인 수학의 집합 연산과 의미와 기능이 같음

- 집합 연산의 종류

![database2](/assets/images/2023-10-20/database2.png)

### 합집합[∪]

- 합집합(union)
  - 수학의 합집합과 같은 개념으로 두 개의 릴레이션으르 합병하여 하나의 릴레이션을 반환
  - 두 릴레이션 R1과 R2의 합집합 R1 ∪ R2가 반환하는 것은 릴레이션 R1 또는 R2에 속하는 모든 튜플들로 구성된 릴레이션

![database3](/assets/images/2023-10-20/database3.png)

### 교집합[∩]

- 교집합(intersect)

* 수학의 교집합과 같은 개념
* 두 릴레이션 R1과 R2의 교집합 R1 ∩ R2가 반환하는 것은 릴레이션 R1과 R2에 동시에 속하는 공통 튜플로만 구성된 릴레이션

![database4](/assets/images/2023-10-20/database4.png)

### 차집합[-]

- 차집합(difference)
  - 수학의 차집합과 같은 개념
  - 두 릴레이션 R1과 R2의 차집합 R1 - R2가 반환하는 것은 첫 번째 릴레이션 R1에는 속하지만 두 번째 릴레이션 R2에는 속하지 않는 튜플로만 구성된 릴레이션

![database5](/assets/images/2023-10-20/database5.png)

![database6](/assets/images/2023-10-20/database6.png)

### 카티션 프로덕트[x]

- 카티션 프로덕트(cartesian product)
  - 두 릴레이션의 모든 튜플을 수평으로 결합하는 연산
    - 두 릴레이션 R1과 R2의 카티션 프로덕트 R1 x R2가 반환하는 것은 첫 번째 릴레이션 R1의 각 튜플에 대해 두 번째 릴레이션 R2의 모든 튜플을 반복하여 앞뒤로 연결(concatenation)한 릴레이션 즉, R1과 R2 튜플들의 모든 조합으로 구성된 결과 릴레이션을 반환
    - 두 릴레이션의 기계적인 조합을 만들기 때문에 그 자체보다는 추가적으로 다른 관계 대수 연산을 조합할 때 유용함

![database7](/assets/images/2023-10-20/database7.png)

### 집합 연산의 기능

- 집합 연산의 종류와 연산적용의 개념

![database8](/assets/images/2023-10-20/database8.png)

- 집합 연산의 적용 결과(차수/카디널리티의 변화)

![database9](/assets/images/2023-10-20/database9.png)

### 1.2 관계 연산

- 관계 연산(relation operation)

  - 릴레이션의 구조적 특성에 기반을 둔 연산을 포함
  - 관계형 데이터 모델을 위해 고안된 연산들

- 관계 연산의 종류

![database10](/assets/images/2023-10-20/database10.png)

### 셀렉트[σ]

- 셀렉트(select)
  - 릴레이션에서 특정 튜플을 추출하는 연산
    - 연산자는 'σ'(시그마, sigma)를 사용
    - 단항 연산(unary operation)
  - 셀렉트 연산 σ선택*조건식(R)이 반환하는 것은 릴레이션 R의 튜플 중에서 명세된 '선택*조건식'을 만족하는 튜플로만 구성된 릴레이션
  - 릴레시연을 수평 분할하는 효과

> σ선택\_조건식 = 참, 거짓을 판별할 수 있는 논리식

예) σ중간성적 < 기말성적(성적)
σ이름 = '홍길동'(성적)
σ(중간성적 < 기말성적)^(이름='홍길동')(성적)
σ(학년=4)(성적)

![database11](/assets/images/2023-10-20/database11.png)

### 셀렉트 연산의 예

![database12](/assets/images/2023-10-20/database12.png)

### 프로젝트[Π]

- 프로젝트(project)
  - 릴레이션에서 특정 속성을 추출하는 연산
    - 연산자는 'Π'(파이, pi)를 사용
    - 단항 연산
  - 프로젝트 연산 Π속성*리스트(R)가 반환하는 것은 릴레이션 R에 속한 속성 중에서 '속성*리스트'에 명세된 속성으로만 구성된 릴레이션
  - 릴레이션을 수직 분할하는 효과

> 속성\_리스트 = 속성명1, 속성명2, ... 속성명n

예) Π이름,성별,학년(학생1)

- 프로젝트 연산의 예

![database13](/assets/images/2023-10-20/database13.png)

### 조인[⋈]

- 조인(join)
  - 두 릴레이션의 공통 속성을 기준으로 조인 조건을 만족하는 튜플을 수평으로 결합하는 연산
    - 연산자는 '⋈'를 사용
    - 두 릴레이션의 관련 튜플들을 결합하기 위해 사용
  - 릴레이션 R1과 R2의 조인 R1⋈조인*조건식R2 가 반환하는 것은 첫 번째 릴레이션 R1의 각 튜플에 대해 두 번째 릴레이션 R2의 모든 튜플을 앞뒤로 반복하여 연결(concatenation)한 튜플 조합 중에서 '조인*조건식'을 만족하는 튜플만으로 구성된 결과 릴레이션

### 세타 조인

- 세타 조인(theta join)
  - '조인*조건식'에 6개의 θ(theta) '비교*연산자'(=, ≠, <, ≤, >, ≥) 중 하나를 사용하는 조인
  - 릴레이션 R1의 '조인*속성'을 a1, 릴레이션 R2의 '조인*속성'을 a2라고 할 때 다음과 같은 세타 조인이 가능함

![database14](/assets/images/2023-10-20/database14.png)

### 동등 조인(equijoin)

- '조인*조건식'에 특별히 '=' '비교*연산자'를 사용하는 세타 조인
- 6개의 세타 조인 '비교\_연산자' 중에서 가장 많이 사용하는 '='를 사용한 조인
- 보통 말하는 조인 연산이 바로 동등 조인

![database15](/assets/images/2023-10-20/database15.png)

### 자연 조인

- 자연 조인(natural join)
  - 동등 조인 결과 중에서 '조인\_조건식'에 사용된 중복 속성을 자동 제거한 조인
  - 동등 조인의 결과 릴레이션에서 중복 속성이 두 번 나오지 않도록 이를 제거한 결과 반환
  - 연산자는 '⋈N' 을 사용

![database16](/assets/images/2023-10-20/database16.png)

### 조인 분류

- 동등 조인은 특정한 유형의 세타 조인임
- 자연 조인은 동등 조인이면서 세타 조인이기도 함

![database17](/assets/images/2023-10-20/database17.png)

### 디비전[÷]

- 디비전(division)
  - 특정 값들을 모두 가지고 있는 튜플을 찾는 연산
  - 두 릴레이션 R1과 R2의 디비전 R1÷R2가 반환하는 것은 R2의 모든 튜플에 연관된 R1의 튜플 중에서 R2에 속한 속성을 제외한 나머지 속성 값만으로 구성된 릴레이션
    - 연산자는 '÷'를 사용
    - 나눗셈 연산과 개념이 비슷하ㅓㅁ
    - 릴레이션 R1이 릴레이션 R2의 모든 속성을 포함하고 있어야 가능
  - R1에서 R2의 모든 튜플을 포함한 튜플의 나머지 속성들로 결과 릴레이션을 구성

![database18](/assets/images/2023-10-20/database18.png)

### 관계 연산의 기능

![database19](/assets/images/2023-10-20/database19.png)

- 기본 연산(primitive operation)

  - 다음 5개의 연산은 필수 연산으로 다른 연산으로 대체될 수 없음
  - ∪(합집합), -(차집합), x(카티션 프로덕트), σ(셀렉트), Π(프로젝트)

- 복합 연산(composite operation)
  - 다음 3개의 연산은 기본 연산을 이용하여 대체할 수 있음
  - ∩(교집합), ⋈(조인), ÷(디비전)

### 관계 대수 연산 요약

![database20](/assets/images/2023-10-20/database20.png)

### 1.3 확장 연산

- 기존 관계 대수 연산을 확장하여 추가로 정의

  - 자연 조인의 확장된 형태인 세미 조인 연산과 외부 조인 연산
  - 합집합의 확장된 형태인 외부 합집합 연산

- 확장 관계 연산의 종류

![database21](/assets/images/2023-10-20/database21.png)

### 세미 조인

- 세미 조인(semijoin)
  - 자연 조인이 반환하는 결과 릴레이션 중에서 한쪽 릴레이션 속성만으로 한정하여 반환하는 제한적 자연 조인 연산
  - 연산자는 '⋉' 또는 '⋊'를 사용
  - 릴레이션 R1과 R2의 세미 조인 R1⋉R2는 R2와의 자연 조인에 참여할 수 있는 R1의 튜플만을 선택하여 반환
  - R2를 '조인\_속성'으로만 프로젝트한 뒤, 결과 릴레이션을 R1에 다시 자연 조인한 결과와 같음

![database22](/assets/images/2023-10-20/database22.png)

### 왼쪽 세미 조인

- 왼쪽 세미 조인(left semijoin)
  - 자연 조인 결과 중 왼쪽 릴레이션의 속성만 반환

![database23](/assets/images/2023-10-20/database23.png)

### 오른쪽 세미 조인

- 오른쪽 세미 조인(right semijoin)
  - 자연 조인 결과 중 오른쪽 릴레이션의 속성만 반환

![database24](/assets/images/2023-10-20/database24.png)

### 외부 조인

- 외부 조인(outer join)
  - 자연 조인 결과에 포함되지 않는, 조인에 실패한 튜플까지 모든 포함하도록 확장한 연산
  - 자연 조인의 확장된 형태
  - 대응 속성 없이 추가된 튜플들은 널 값을 채워서 반환
  - 모든 튜플을 반환하는 대상 릴레이션의 위치에 따른 분류
    - 완전 외부 조인 (⟗)
    - 왼쪽 외부 조인 (⟕)
    - 오른쪽 외부 조인 (⟖)

### 완전 외부 조인

- 완전 외부 조인(full outer join)
  - 왼쪽과 오른쪽 R1, R2 릴레이션의 모든 튜플을 빠짐없이 조인 결과에 포함하도록 대응. 튜플이 없는 경우 널 값을 채워서 반환

![database25](/assets/images/2023-10-20/database25.png)

### 왼쪽 외부 조인

- 왼쪽 외부 조인(left outer join)
  - 왼쪽 R1 릴레이션의 모든 튜플을 빠짐없이 조인 결과에 포함하도록 대응 튜플이 없는 경우 널 값을 채워서 반환

![database26](/assets/images/2023-10-20/database26.png)

### 오른쪽 외부 조인

- 오른쪽 외부 조인(right outer join)
  - 오른쪽 R2 릴레이션의 모든 튜플을 빠짐없이 조인 결과에 포함하도록 대응 튜플이 없는 경우 널 값을 채워서 반환

![database27](/assets/images/2023-10-20/database27.png)

### 외부 합집합

- 외부 합집합(outer join)
  - 합병 가능하지 않은(정확히 말하면 부분적으로만 합변 가능한) 두 릴레이션의 튜플을 합병
  - 대응하는 속성이 없는 경우도 널 값을 채워 모든 튜플을 결과 릴레이션에 포함

![database28](/assets/images/2023-10-20/database28.png)

### 2. 관계 대수의 활용

- 데이터베이스 사용자가 요청한 SQL 문장은 DBMS 내부에서 해석되어 처리
  - 절차가 명세되지 않은 SQL 문장을 내부적으로 처리하기 위해서는 DBMS는 그 처리 순서와 방법을 결정해야 함
  - DBMS는 SQL 질의문을 처리하기 위해 내부적으로 관계 대수식을 스스로 작성하고 연산자를 순서대로 적용함으로써 질의 결과를 생성

### 관계 대수식 작성 예

![database30](/assets/images/2023-10-20/database30.png)

### 복수의 관계 대수식 작성

- 같은 질의 요청에 대해서 여러 관계 대수식 표현이 가능
  - 같은 결과를 가져오더라도 적용하는 관계 대수 연산자의 종류와 순서가 다양할 수 있기 때문
  - 여러 관계 대수식 중에는 상대적으로 보다 효율적인 관계 대수식과 비효율적인 관계 대수식이 존재
  - 최적의 관계 대수식을 작성하는 것은 DBMS의 핵심 역할
  - 예) '김연아' 학생이 수강한 과목번호와 평가학점을 검색하시오.

![database29](/assets/images/2023-10-20/database29.png)
