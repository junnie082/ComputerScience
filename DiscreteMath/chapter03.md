# Discrete Math 3

# Chapter 03 증명

#### 2024.04.16.(화)

### 3.1 증명의 이해

### 정의 3-1 증명(proof)

증명(proof)이란 가정에서 논리적 법칙을 이용하여 결론을 이끌어내는 것을 말한다. 이때 추론이 참이면 진위(valid)추론이라 하고, 추론이 거짓이면 허위(fallacious) 추론이라 한다.

### 정의 3-2 공리(axiom)

별도의 증명 없이도 항상 참(T)이라고 판단되는 명제

### 3.2 직접 증명법

### 정의 3-5 직접 증명법(direct proof)

조건명제 p -> q가 참(T)임을 증명하기 위해 전제 p를 참(T)으로 가정했을 때, 결론 q도 참(T)임을 증명하는 방법

- 논리 함축을 증명하기 위한 방법

(1) P -> Q의 vacuous 증명 방법

- P가 거짓이라 하면 P -> Q는 항상 참이다.
  그래서 P -> Q가 참인 것을 보이기 위해 P가 거짓이라는 것만 보이면 된다.

(2) P -> Q의 trivial 증명 방법

- Q가 참이라고 하면 P -> Q는 참이다.
  그래서 P -> Q가 참인 것을 보이기 위해 Q가 참이라는 것만 보이면 된다.

| P Q | P -> Q |
| T T | T |
| T F | F |
| F T | T |
| F F | T |

### 3.2 직접 증명법

- 두 홀수 m과 n의 곱이 홀수임을 증명
  - p -> q: 두 정수 m과 n이 홀수이면, m과 n의 곱은 홀수이다.
  - p: 두 정수 m과 n이 홀수이다.
  - q: m과 n의 곱은 홀수이다.

m = 2k + 1
n = 2l + 1

mn = (2k + 1)(2l + 1) = 4kl + 2k + 2l + 1 = 2(2kl + k + l) + 1 = 2a + 1

따라서 명제 '두 홀수 m과 n의 곱은 홀수이다.'는 참(T)

### 3.3 간접 증명법

### 3.3.1 모순 증명법

- 간접 증명(indirect proof) 방법
  - 가정된 명제로부터 추론에 의해서 결론에 직접 도달되기가 어려운 경우에 간접적으로 결론이 참인 것을 이끌어내는 방법
    - 모순, 대우 증명, 반례 증명, 존재 증명(existence proof) 등 4가지로 나누어 볼 수 있다.

### 정의 3-6 모순 증명법(proof by contradiction)

조건명제 p -> q 와 not(p and not q)가 동치임을 이용해, p and not q 가 거짓(F)임을 보임으로써 증명하는 방법

not (p and not q) == not p or not(not q) ---> 드 모르간의 법칙

== not p or q ---> 이중 부정법칙
== p -> q ---> 함축법칙

### 3.3.1 모순 증명법

- 두 홀수 m과 n의 곱이 홀수임을 증명
  - p: 두 정수 m과 n이 홀수이다.
  - q: m과 n의 곱은 홀수이다.
  - not q: m과 n의 곱은 홀수가 아니다. (짝수이다.)
  - p and not q: 두 정수 m과 n이 홀수이고, m과 n의 곱은 홀수가 아니다. (짝수이다.)

m = 2k + 1, n = 2l + 1

mn = (2k + 1)(2l + 1) = 4kl + 2k + 2l + 1 = 2(2kl + k + l) + 1 = 2a + 1

따라서, 명제 '두 정수 m과 n이 홀수이고, m과 n의 곱은 홀수가 아니다.(짝수이다.)'는 거짓(F)

명제 '두 홀수 m과 n의 곱은 홀수이다.'는 참(T)

### 3.3.2 대우 증명법

### 정의 3-7 대우 증명법(proof by contrapositive)

조건명제 p -> q와 이에 대한 대우 명제 not q -> not p 가 동치임을 이용하여 증명하는 방법

### 3.3.3 존재 증명법

### 정의 3-8 존재 증명법(existence proof)

명제가 참(T)이 되는 예를 찾아서 증명하는 방법

### 3.3.4 반례 증명법

### 정의 3-9 반례 증명법(proof by counter-example)

명제가 모순이 되는 예를 찾아서 증명하는 방법

## 3.4 수학적 귀납법

### 수학적 귀납법

- 새로운 결과를 얻기 위한 대표적인 논증 방법: 연역법, 귀납법

* 연역법(deducation)

  - 일반적인 사실(fact)이나 원리들을 전제로 하여 추론(inference)을 통하여 구체적인 새로운 사실을 이끌어내는 방법이다.
  - 이 과정에서 직접 보고 듣고 느끼는 등의 경험을 필요로 하지 않는 순수한 생각만 사용한다.
  - 연역법의 가장 전형적인 예로 가언 삼단논법이 있다.
  - "소크라테스는 사람이다", "사람은 죽는다", 그래서 "소크라테스는 죽는다"이다. 즉, 가정으로부터 결론을 이끌어 내는 추론을 했다.

* 귀납법(induction)

  - 연역법과는 정반대의 방식이다.
  - 개벌적인 사실들을 종합하여 일반적인 원리를 도출해내는 것이다.
  - 관찰과 실험에 기반을 둔 가설을 귀납 추론을 통하여 일반적인 규칙을 입증하는 것이다.

* 수학적 귀납법(mathematical induction)
  - 명제가 참이라는 것을 증명하기 위한 방법이다.
  - 객체(object)들의 연속(sequence)을 정의하기 위해서 사용된다.

### 정의 3-10 수학적 귀납법(mathemeatical induction)

수학적 귀납법은 k를 어떤 정수라 할 때 어떤 명제 P(n)이 n >= k 인 모든 수에 대해서 모두 참인 것을 보여주기 위한 방법으로, 다음과 같이 증명하는 방법을 말한다.

1. 기본 가정: 명제의 논의영역 D의 첫 번째 값 d에 대하여, P(d)가 참(T)임을 보인다.
2. 귀납 가정: 논의영역에 속하는 임의의 값 k에 대하여, P(k)가 참(T)이라고 가정한다.
3. 귀납 증명: 기본 가정과 귀납 가정을 이용해 논의영역에 속하는 값 k+1에 대하여, P(k+1)이 참(T)임을 증명한다.

- n >= 1인 자연수 n에 대하여 1 + 2 + ... + n = n(n+1)/2 임을 증명
  - 논의영역 D = {n|n >= 1}
  - 명제 P(x) = 1 + 2 + ... + n = n(n+1)/2
  - 기본가정: P(1): 1 = 1(1+1)/2 --> P(1)이 참(T)
  - 귀납가정: P(k): 1 + 2 + ... + k = k(k+1)/2 이 참(T)이라고 가정
  - 귀납증명: P(k+1): 1 + 2 + ... + k + (k+1) = (k+1){(k+1)+1}/2이 성립하는지 증명

### 프로그램 검증

- 프로그램 검증(program verification): 매우 어려운 문제

  - 우리가 어떤 문제를 해결하기 위해 프로그램을 작성한다.
  - 이 프로그램이 항상 정확한 결과를 생성한다는 것을 어떻게 확신할 수 있는가?
  - 프로그래머에게는 너무나도 어려운 문제이다.
  - 하지만 프로그래머 입장에서는 최대한 검증을 해야만 한다.
  - 하지만 원칙적으로 모든 프로그램의 정확성을 검증하는 방법은 존재하지 않는다. (이것은 튜링(Alan Turing)에 의해 증명되었다.)

- 프로그램 검증은 소프트웨어 개발과 품질에 관한 부분이다.

  - 소프트웨어의 품질이란 프로그램이 정상적으로 작동해야 하고, 고객이 의도한대로 요구사항을 올바르게 정의하고, 그 명시된 요구사항을 만족시키는 것을 말한다.

- 정확한 프로그램이 되기 위해서는 구문 에러(syntax error)를 포함하지 않아야 하고, 예상치 못하게 끝나서도 안되며, 주어진 입력에 대해 정확한 결과를 도출해야만 한다.

- 즉, 수학적 검증 방법들을 통해 프로그램의 결과가 정확한지, 프로그램이 정상 종료되는지, 변수들의 값이 어떻게 변하는지 등을 검증하는 것이다.

### 정적인 방법

- 프로그램의 검증 방법: 정적(static)인 방법
  - 프로그램을 실행하지 않고 결함을 찾아내는 것으로 여러 참여자들이 모여 프로그램을 검토하여 결함을 찾아내는 것이다.
  - 수학적 귀납법을 포함하여 2장에서 설명한 추론 규칙과 증명 방법들을 사용하기도 하며, 프로그램을 일련의 부프로그램들로 분할하고 각 부프로그램들이 정확하다는 것을 보임으로써 프로그램의 정확성을 증명하는 유용한 추론 규칙들도 있다.
  - 정적으로 에러를 검출하는 프로그램 검증 도구 중 대표적인 것은 컴파일러이다.

* 프로그램을 정적으로 검증하는 가장 기본적인 방법: 각각의 문장들에 대한 기본 흐름도가 잘되어 있는지 확인하는 것

* 이 중에서 반복문에서 루프를 빠져나가는 문장과 goto와 같은 무조건 분기문을 사용할 경우에는 프로그램의 정확성을 검증하는 데 각별히 유의해야 한다.

* 소스 프로그램을 검토할 때 검토할 체크 리스트
  - 요구사항 명세서에 기술된 기능은 충분히 코드에서 실행되는지?
  - 요구사항 명세서에 기술되지 않은 추가적인 기능이 코드에서 실행되지는 않는지?
  - 함수의 리턴값은 적절하게 사용되는가?
  - 모든 지역/전역 변수가 사용 전에 초기화되는가?
  - 함수는 정확하게 호출되는가?

### 동적인 방법

- 프로그램의 검증 방법: 동적인 방법

  - 소프트웨어를 실행하여 결함을 찾아내는 방법으로 시험 데이터를 통하여 테스팅하는 방법으로 결함을 찾아내는 방법이다.

- 블랙박스 테스팅(black-box testing)

  - 요구사항 명세 요구사항 명세서나 설계서를 참조하면서 수행
  - 로직에는 관심이 없고, 단지 입, 출력값을 테스트한다.
  - 주로 경계값들을 테스트한다.

- 화이트박스 테스팅(white-box testing)

* 소스 코드를 직접 참조하면서 수행한다.
* 모든 코드가 한번은 실행되게 입력하는 문장(statement)의 범위(coverage)와 분기(branch), 조건(condition), 다중 조건(multiple condition) 등을 주로 테스트 한다.
