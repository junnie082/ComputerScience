# Go-Back-N 프로토콜

[GBN (Go-Back-N) 프로토콜이란](<https://techmate.site/posts/GBN-(Go-Back-N)-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4%EB%9E%80/>)

#### 2024.05.22.(수)

## 0. GBN 이란?

먼저 Go-Back-N 프로토콜을 공부하기 앞서 신뢰적 데이터 전송의 원리에 대해 짚고 넘어가자. 트랜스포트 계층에서 말하는 신뢰적인 데이터 전송의 기준은 데이터가 손실되지 않고 순서대로 송신자에서 수신자로 데이터가 이동해야 한다.

이런 신뢰적 데이터 전송을 위해 stop-and-wait 방식을 이용하는 것이 rdt 방식이고 여기에 성능을 위해 파이프라이닝을 적용한 방식이 GBN 프로토콜이다. 따라서 rdt까지 사용되던 방법들이 대부분 그대로 GBN에 적용이 되고 파이프 라이닝을 위한 추가적인 Sequence Number와 버퍼링을 이용하는 것이 GBN 프로토콜이다. GBN 프로토콜은 파이프라이닝을 통하여 송신자의 확인응답을 기다리지 않고 여러 패킷을 전송할 수 있다.

## 1. GBN 프로토콜의 구성

GBN에서 확인 응답 (ACK)이 안오고도 계속 보내기 위해서 해당 정보를 버퍼링해야 한다. 따라서 GBN에서 사용하는 방법은 바로 **윈도우 프로토콜**이다. 확인응답이 되지 않은 패킷의 최대 허용 수를 Window size보다 작거나 같게하여 파이프라인으로 한번에 보낼 수 있는 패킷의 양을 조절한다.

![1](/assets/images/2024-05-22/1.png)

이 그림은 송신자의 Sequence Number 범위를 보여주는 그림이다. send_base 이전의 패킷은 이미 전부 ACK를 받은 패킷들이고 send_base부터 nextseqnum이 현재 ACK를 받아야 하는 패킷들이며 nextseqnum부터 send_base + N에 해당하는 부분은 지금 현재 송신자가 보낼 수 있는 패킷이다.

이런 요소들을 이용하여 송신자는 ACK가 도착하지 않은 패킷들을 체크하며 앞으로 추가적으로 몇개의 패킷을 수신자에게 보낼 수 있는지 판단한다.

따라서 핵심은

> > 전송되었지만 아직 ACK가 도착하지 않은 패킷과 앞으로 보낼 수 있는 패킷을 한번에 묶는 크기 N인 윈도우가 중요하다.

## 2. GBN의 동작 과정

먼저 **송신자의 입장**이다.

1. 송신자는 상위로부터 호출이 되면 해당 데이터를 받아와서 수신자에게 전송해야 한다. 이때 송신자의 윈도우 사이즈 N보다 확인 응답을 받지 못한 패킷의 개수가 적다면 송신자는 데이터를 받아올 수 있고 해당 데이터를 패킷을 전송할 것이다. 하지만 N과 확인 응답이 되지 않은 패킷의 수가 같다면 상위 계층에서 온 데이터를 거부한다.

1. 수신자가 보낸 ACK를 받게 되면 해당하는 ACK의 이전의(윈도우 범위 내의) 패킷들을 모두 확인 응답 받은 것으로 처리하고 send_base의 값을 받은 ACK의 Sequence Number + 1 로 설정한다. 핵심은 바로 수신 측에서 관리하는 올바르게 수신된 누적확인 응답 번호다.

1. 타이머는 1개를 이용하며 처음 패킷을 보내기 시작할 때 send_base값과 next_seqnum 값이 같을 경우 timer를 작동시킨다. 패킷에 대한 ACK를 받은 상태라면 그 시점에서 다음 확인 응답을 받지 않은 패킷에 대한 timer를 작동시킨다. 타임아웃이 나면 send_base부터 next_seqnum까지 모든 패킷을 재전송한다.

수신자는 Sequence Number n을 가진 패킷이 오류없이 그리고 순서대로 수신된다면 수신자는 패킷 n에 대한 ACK를 송신하고 상위 계층(Application Layer)으로 데이터를 전달한다. 그 외의 경우(순서대로 패킷이 오지 않는 경우) 해당 패킷을 버리고 가장 최근에 보낸 Sequence Number의 ACK를 보낸다.
예를 들면, 가장 최근에 4번에 패킷에 대한 ACK를 보냈고 현재 5번 패킷이 와야 되는데 6번 패킷이 먼저 온다면 4번 패킷에 대한 ACK를 보낸다.

```
GBN에서 누적 확인 응답이란?
패킷이 상위 계층에 한번에 하나씩 전송되므로 만일 Sequence Number가 k인 패킷이 수신되고 상위 계층에 전달 되었다면 k-1까지의 패킷은 모두 수신자에게 전달 되었다는 점을 의미한다.
```

## 3. GBN 프로토콜 예시

`정상적인 수행과정: `

1. 2번 패킷이 손실되고 이후 0번과 1번 ACK가 도착한 후에 윈도우가 이동한다. 이후 3번 패킷의 ACK에는 가장 최근에 받은 패킷인 1번 ACK가 보내진다.

2. 이후 4번, 5번 패킷이 보내지고 3번 패킷에 대한 NAK(1번 ACK)가 보내지면 송신자는 아무 행위도 하지 않는다.

3. 이후 2번 패킷에 대한 타이머가 끝나며 2번 패킷부터 5번 패킷까지 모두 재전송 하는 것을 볼 수 있다.

`윈도우 사이즈와 Sequence Number가 같을 경우 발생할 수 있는 문제점: `

1. 정상적인 예시와 똑같이 3번 패킷까지 보내지만 1번과 2번 패킷이 정상적으로 수신자에게 도착하지 않는다.

2. 이 상황에서 0번 패킷에 대한 ACK는 정상적으로 도착하고 윈도우가 오른쪽으로 한칸 이동한다.

3. 3번 패킷에 대한 ACK로 아직 누적확인 응답이 0번까지밖에 안쌓여서 0번에 대한 ACK를 보낸다.

4. 송신자 0번 ACK를 현재 윈도우에서 제일 마지막 0번으로 확인하고 send_base를 1에서 다음 1까지 이동한다. 이때, 아직 1번 2번 3번 패킷을 수신자가 받지 않았지만 송신자에서는 받았다고 처리하게 되며 문제가 발생하게 된다.

만약 Sequence Number가 4까지였다면 어떤 결과가 나왔을까?
아마 Time out 전까지 0번 ACK가 도착하면 위의 경우처럼 윈도우를 이동시키지 않았을 것이다.

따라서 아래와 같은 결론을 내릴 수 있다.

```
(window size) N < Sequence Number
```

## 4. GBN 정리

먼저, GBN의 장점은 파이프라이닝으로 이전의 rdt의 stop-and-wait을 해결했다는 점이다. 또한 timer를 하나만 써서 해결하여 타이머에 대한 오버헤드가 적다는 점을 들 수 있다. 하지만, 매 타임아웃마다 모든 확인 응답을 받지 못한 패킷을 재전송한다는 점에서 불필요한 데이터로 파이프라인이 채워지게 되므로 성능적인 면에서 좋지 못하다는 점을 들 수 있다.
따라서, Selective Repeat이라는 Timer를 여러 개 두는 방법과 TCP 상에서 누적 확인 응답을 적절하게 사용하는 방법으로 이런 여러 번 재전송하는 문제점을 해소한 방법들이 존재한다.
