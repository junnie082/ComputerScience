# TCP Flow Control, 흐름제어

## [[Network] TCP Flow Control, 흐름제어](https://velog.io/@nnnyeong/Network-TCP-Flow-Control-%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4)

#### 2024.05.26.(일)

## 흐름제어

TCP 송수신 과정에서 만약 수신측에서 처리할 수 있는 양보다 송신측의 전송량이 더 많다면 어떻게 될까?
전송된 패킷이 수신측 큐에 들어가지 못하고 손실되어 버리는 일이 발생할 것이다!

이러한 데이터 손실을 방지하기 위해 흐름제어가 필요한데, 즉 흐름제어란

```
흐름제어란?

송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법이다.
```

이러한 흐름 제어의 방법 중 대표적인 두가지를 살펴보면, **_Stop and Wait_**과 **_Sliding Window_**가 있다!

## Stop and Wait (정지-대기)

Stop and Wait 은 매우 단순한 방법이다.
보내고, 기다렸다가, 확인이 되면 다시 보낸다.

> > 매번 전송한 패킷에 대해 응답을 받아야만 다음 패킷을 보낼 수 있다.

![2](/assets/images/2024-05-26/2.png)

매우 간단하지만 이로 인해 매우 **_비효율적인 느린_** 방법이다.

## Sliding Window

Stop and Wait 방법의 비효율성을 개선시킨 방법이다.

> > 수신측에서 설정한 윈도우 크기 만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절한다!

이 때 `윈도우`란 **_송신, 수신 스테이션 양쪽에서 만들어진 버퍼_**를 말하고, 이 윈도우의 크기는 **_[가장 최근 ACK로 응답한 프레임 수] - [이전에 ACK 프레임을 보낸 프레임 수]_**이다.

TCP로 통신하는 송신측, 수시측은 각각의 윈도우를 유지한다.
송신측은 송신 윈도우를 유지해 송신 윈도우 크기만큼 한번에 데이터를 보낼 수 있고, 수신측도 수신 윈도우를 유지하며 수신 윈도우 크기만큼 데이터를 한번에 받을 수 있다.

이때 양측 윈도우의 크기는 지난 포스팅에서 다룬 **_TCP 헤더의 Window Size_** 필드에 의해 설정되게 된다.

![3](/assets/images/2024-05-26/3.png)

#### 송신 윈도우

- 현재 송신 윈도우의 크기 (=4) 만큼 ACK 수신 없이 보낼 수 있음
- 1,2 번은 이미 ACK 수신 완료되었으며 3~6은 즉시 전송 가능한 상태, 7~10은 아직 전송할 수 없음

#### 수신 윈도우

- 현재 수신 윈도우 크기는 4이고 최대 4Byte 까지 ACK 송신 없이 받을 수 있음을 의미
- 만약 들어오는 세그먼트에서 처음 수신되는 바이트가 3이 아니라면 이는 순서대로 도착하지 않음을 의미!
- 재조립을 위해 버퍼에 보관한 뒤 수신하는 바이트가 기다리던 3이면 즉시 처리한 후, ACK를 전송한 후 윈도우를 한 칸 이동시킴

![4](/assets/images/2024-05-26/4.png)

#### 송신 윈도우

- 3,4를 전송하면 이에 대한 ACK 응답이 올 때까지 대기
- 5,6은 즉시 전송이 가능함
- 이때, 만약 3,4를 전송하고 `RTO(retransmission timeout)`까지 ACK가 도착하지 않으면 3,4가 포함된 세그먼트가 유실되었다고 판단 후 재전송

#### 수신 윈도우

- 3,4를 수신한 후 윈도우를 2칸 이동
- `ACK 5`를 전송하여 다음에 수신되어야 할 바이트가 5라고 알려줌
- 재전송된 세그먼트를 받은 경우 윈도우가 이미 중복된 세그먼트(3,4)를 포함하지 않으므로 중복 세그먼트는 무시하고 ACK 5 만 재전송한다.

하지만, **_RTO 타이머가 만료되었다는 것이 항상 세그먼트의 유실을 의미하지는 않는다!_** 세그먼트가 아직 수신측에 도달하지 않았을 수도 있고, 수신측에서 보낸 ACK 응답이 유실되었을 수도 있다!
