# Transport Layer (전송 계층)

[Transport layer](https://velog.io/@jeongbeom4693/Transport-layer%EC%A0%84%EC%86%A1-%EA%B3%84%EC%B8%B5)

#### 2024.05.19.(일)

전송 계층은 OSI 7계층에서 4계층을 맡고 있다.

```
전송 계층(Transport Layer)은 계층 구조의 네트워크 구성요소와 프로토콜 내에서 송신자와 수신자를 연결하는 통신 서비스를 제공한다.
```

트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스들 간의 `논리적 통신(logical communication)`을 제공한다.

```
논리적 통신은 애플리케이션 관점에서 보면 프로세스들을 동작하는 호스트들이 직접 연결된 것처럼 보인다는 것을 의미한다.
```

- 트랜스포트 계층은 애플리케이션 간의 물리적 통신보다는 논리적 통신을 제공함

트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다.
프로세스로부터 수신한 메세지를, 트랜스포트 계층 `세그먼트(segment)`인 트랜스포트 계층 패킷을 변환해서 네트워크 계층에 전달한다.

세그먼트로 만들기 위해 작은 조각으로 분할하고, 각각의 조각에 트랜스포트 계층 `헤더`를 추가함으로써 수행된다. 이것을 네트워크 계층에 전달하고, 여기서 세그먼트가 네트워크 계층 패킷(데이터그램) 안에 `캡슐화`되어 목적지로 전달된다.

1. 프로세스에서 받은 메세지를 송신 측의 트랜스포트 계층에서 트랜스포트 계층 패킷으로 변환
2. 헤더 추가 후 네트워크 계층에 전달
3. 데이터그램 안에 캡슐화
4. 전달

세그먼트를 넘겨주는 과정에서 `네트워크 계층에서 이 세그먼트를 검사하는 일은 없다`

트랜스포트 계층과 네트워크 계층은 굉장히 밀접한 관계를 가지고 있다.

## 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 `프로세스`들 사이의 논리적 통신을 제공하지만, 네트워크 프로토콜은 `호스트`들 사이의 논리적 통신을 제공한다.

만약, A라는 집의 누군가와 B라는 집의 누군가가 `우편물(애플리케이션 메세지)`를 주고 받는다고 생각해 보자.

이 과정에서 A라는 집과 B라는 집은 `종단 시스템(호스트)`를 뜻하게 된다.

서로의 집까지 전달되는 우편 서비스는 `네트워크 계층 프로토콜`을 의미한다.

이 우편물은 해당 집의 가족 구성원 중 한명의 것일 것이다. 해당 우편물이 특정 인원에게 전달 되는 그 과정이 `트랜스포트 계층 프로토콜`이라고 보면 된다.

여기서 그 누군가는 `프로세스`다.

즉, 누군가(프로세스)가 메세지를 작성해서 문(소켓)을 거쳐서 우편물을 보내서 도착지에 도착을 한 후(네트워크 계층) 그것을 특정 인원이 넘겨 받는 과정(트랜스포트 계층)을 비유한 것으로 볼 수 있다.

트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜의 서비스 모델에 의해서 제약을 받는다.

만약, 네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 지연 보장이나 대역폭 보장을 제공할 수 없다면, 트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메세지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다는 것을 의미한다.

그럼에도 불구하고 특정 서비스는 이러한 상황에서도 트랜스포트 프로토콜에 의해 제공될 수 있다. 예를 들어, 네트워크 프로토콜이 패킷을 분실하거나 손상하거나 복사본을 만들 때(비신뢰적일 때)에도 애플리케이션에게 신뢰적인 전송 서비스를 제공할 수 있다. (ex. 암호화 사용)

## 개요

일반적으로 `TCP/IP 네트워크`는 애플리케이션 계층에서 두 가지 구별되는 트랜스포트 계층 프로토콜을 제공한다.

1. `UDP(User Datagram Protocol)`: 비신뢰적이로 비연결형 서비스 제공
2. `TCP(Transmission Control Protocol)`: 애플리케이션에게 신뢰적이고 연결지향형 서비스를 제공

애플리케이션 개발자는 소켓을 생성할 때 TCP와 UDP 중에서 하나를 선택해야 한다.

```
!! 용어 정리
* 트랜스포트 전송 패킷(TCP, UDP 패킷) => `세그먼트`
* 네트워크 계층 패킷 => `데이터그램`
```

```
! IP(Internet Protocol)
IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 `최선형 전달 서비스(best-effort delivery service)이다.

이것은 IP가 통신하는 호스트들 간에 세그먼트를 전달하기 위해서 최대한 노력하지만, 어떤 보장도 하지 않는다는 것을 의미한다.

내부의 무결성(integrity)를 보장하지 않기 때문에 비신뢰적인 서비스(unreliable service)라고 부른다.
```

```
! 데이터의 무결성

데이터의 정확성, 일관성, 유효성이 유지되는 것을 의미한다. 여기서 정확성이란 중복이나 누락이 없는 상태를 뜻하고, 일관성은 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태를 뜻한다.

위에서 말하는 내부의 무결성은 세그먼트의 전달을 보장하지 않고, 순서를 보장하지 않는 것을 의미한다.
```

UDP와 TCP는 헤더에 오류 검출 필드를 포함함으로써 오류 검출 필드를 검사한다.

UDP의 경우 IP 비슷한데, UDP는 IP와 같이 비신뢰적 서비스이다.

반면에 TCP는 `신뢰적인 데이터 전달(reliable data transfer)`을 제공한다.

대표적인 기능들을 나열해 보자면 다음과 같다.

- 흐름제어
- 순서번호
- 확인응답
- 타이머

이러한 기능을 사용함으로써 데이터의 무결성을 유지한다. 이외에도 과도한 양의 트래픽을 제어하는 `혼잡제어` 기능도 있다.

이외에도 TCP와 UDP의 기본적인 기능이 있다.
종단 시스템 사이의 IP 전달 서비스를 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장하는 것이다.

```
"호스트-대-호스트 전달"을 "프로세스-대-프로세스 전달"로 확장하는 것을 트랜스포트 다중화(transport multiplexing)와 역다중화(demultiplexing)라고 부른다.
```

### 다중화와 역다중화

수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 전달하지 않고, 중간 매개체인 소켓을 통해 전달하는 것은 프로세스와 소켓을 다루는 부분에서 배웠다.

수신 측에서 다루고 있는 소켓이 하나 이상일 수가 있으므로, 각각의 소켓은 어떤 하나의 유일한 식별자를 가져야 한다.

이 식별자의 포맷은 소켓이 UDP 소켓인지 또는 TCP 소켓인지에 따라 달라진다.

여기서 다중화와 역다중화 개념이 나온다. 먼저 정리부터 하자면 다음과 같다.

```
! 다중화: 출발지 호스트에서 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해서 각 데이터 헤더 정보로 캡슐화하고, 그 세그먼트들을 네트워크 계층에 전달하는 작업
```

```
! 역다중화: 전달 받은 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업
```

수신받은 세그먼트를 적절한 프로세스에 보내기 위해서는 반드시 역다중화가 이루어져야 한다.

```
사실, 트랜스포트 계층에서 다중화와 역다중화를 다루고 있지만, 기본적으로 이들은 한 계층(트랜스포트 포함 다른 계층)에서의 한 프로토콜이 그 상위 계층의 여러 프로토콜에 의해 사용될 때마다 관련된다.
```

트랜스포트 다중화에는 두 가지 요구 사항을 가지고 있다.

1. 소켓은 `유일한 식별자`를 가진다.
2. 각 세그먼트는 전달될 적절한 소켓을 가르키는 `특별한 필드`를 가진다.

여기서 `특별한 필드`는 `출발지 포트 번호 필드(source port number field)`와 `목적지 포트 번호 필드(destination port number field)`이다.

UDP의 경우 `"목적지 IP"`와 `"목적지 포트 번호"`만으로 목적지 소켓이 결정된다. 즉, 출발지 IP와 출발지 Port 번호는 상관이 없다.

하지만, TCP의 경우 `"출발지 IP 주소"`, `"출발지 포트 번호"`, `"목적지 IP 주소"`, `"목적지 포트 번호"`에 의해 식별된다.

트랜스포트 계층은 이러한 필드들을 보고 상응하는 소켓으로 세그먼트를 보낸다.

웹 서버가 각각의 연결에 따라서 새로운 프로세스를 만든다. 그 이유는 출발지 IP와 출발지 Port가 다르기 때문이다.

그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응이 일어나는 것은 아니다. 실제로, 오늘날의 많은 고성능 웹 서버들은 `하나의 프로세스`만을 사용한다. 그러면서, 각각의 클라이언트 연결을 위해 `새로운 연결 소켓`과 함께 `새로운 스레드(가벼운 서브프로세스)`를 생성한다.
