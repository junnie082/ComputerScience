# [TCP/IP] iterative 기반의 서버, 클라이언트 구현

### [[TCP/IP] iterative 기반의 서버, 클라이언트 구현](https://kscodebase.tistory.com/224)

#### 2024.05.29.(수)

iterative 라는 말 때문에 복잡해 보일 수 있는데, 사실 이건 "반복적인"이라는 뜻에 불과하다.
반복적이라니, 도대체 무엇이 반복적이란 말인가?

지금 우리가 소켓 프로그래밍을 해본 걸 보면, 서버와 연결되는 즉시 값을 반환하고 양측의 소켓이 종료된다.

이런 식으로 만들면 안된다, 소켓이 몇 개인지 알고, 또 정보 요구가 몇 번이나 올 줄 알고 1회성 서버를 만드는가.

**_그래서, 반복문으로, accept() 함수를 여러 번 반복시킨다, 또는 무한히 반복시킨다_**

어디서부터 어디까지가 반복인지 설명하기 위해서 아래의 도식을 봐주길 바란다.

1. socket()
2. bind()
3. listen()
4. accept()
5. read() / write() // 데이터를 송수신한다. 이는 리눅스일 경우의 함수이고, 윈도우일 때에는 send()와 connect() 였다.
6. close(client) // accept()로 만들어진 데이터 송수신 소켓의 종료
7. close(server) // 서버 소켓의 종료

이게 서버의 흐름일 텐데, 여기서 4~6이 반복되게 만들어 주면 된다, 데이텉 송수신 소켓이 종료된 후, 다시 accept()로 가게끔 해주면 되는 것이다.
당연한 이야기지만 데이터 송수신 소켓은, 이미 클라이언트 1개를 지정하여 연결되어 있는 상태니 새로 만들어야 한다.
당연히, 클라이언트에는 차이가 없다.

iterative 에코 서버의 동작 방식을 정리해보고, 다음 포스팅에서는 server를 구현해보겠다. (클라이언트는 동일하다.)

(에코 서버의 정확한 의미는 클라이언트가 서버로 데이터를 전송하면 서버는 그 데이터를 받았다가 그대로 돌려주는 서버를 의미한다, 서버와 클라이언트 간에 몇 바이트의 데이터를 수신할 수 있을지 예상하기 위해서 만든다.)

- 서버는 한 순간에 하나의 클라이언트와 연결되어 에코 서비스를 제공한다.
- 서버는 총 5개의 클라이언트로부터 순차적으로 서비스를 제공하고 종료한다.
- 클라이언트는 프로그램 사용자롤부터 문자열 데이터를 입력 받아서 서버에 전송한다.
- 서버는 전송받은 데이터를 클라이언트로 재전송한다 == 서버는 클라이언트에게 에코한다.
- 서버와 클라이언트 간 문자열 에코는 클라이언트가 종료 문자를 입력할 때까지 계속된다.
