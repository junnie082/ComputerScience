# DataPath

#### 2024.12.02.(월)

### [[컴퓨터 구조] 프로세서[0] - 데이터패스 구현](https://ttl-blog.tistory.com/1033#%F0%9F%A7%90%20R%20%ED%98%95%EC%8B%9D%20%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98%20%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%A8%EC%8A%A4-1)

기본적인 RISC-V 구현 개요

```
메모리 참조 명령어: ld, sd
산술 논리 명령어: add, sub, and, or
조건부 분기 명려어: beq
```

이러한 명령어를 구현하는 데 필요한 것의 대부분은 명령어가 어떤 명령어인지와 상관없이 동일하다.

모든 명령어의 첫 두 단계는 다음과 같이 동일하다.

1. `프로그램 카운터(PC)`를 프로그램이 저장되어 있는 메모리에서 보내서 메모리로부터 명령어를 가져온다.
2. 읽을 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 2개의 `레지스터를 읽는다`.

그러나 이 이후부터는 명령어의 종류에 따라 수행해야 할 행동들이 달라진다.

RISC-V 명령어 집합의 단순함과 `규칙적인 특성`이 많은 종류의 명령어 실행을 비슷하게 만들어 줌으로써 구현을 `단순화`한다.

예를 들어 모든 명령어 종류는 레지스터를 읽은 후 ALU를 사용하는데, 각각의 목적은 다음과 같다.

- `메모리 참조` 명령어(ld, sd)는 `주소 계산`을 위해 사용한다.
- `산술, 논리` 명령어는 `연산`을 수행하기 위해 사용한다.
- `조건부 분기` 명령어는 `비교`하기 위해서 사용한다.

ALU를 사용한 후 명령어 실행을 끝내기 위해 필요한 동작은 명령어 종류에 따라 서로 다르다.

### 간단한 데이터패스

아래 그림은 여러 기능 유닛(장치)들과 그들 사이의 연결(데이터패스)을 추상적으로 표현한 것이다.

위 그림은 프로세서 내의 데이터 흐름을 거의 다 보여주고 있지만 명령어 실행에 필요한 두 가지 측면이 제외되어 있다.

첫째로, 서로 다른 source에서 나온 데이터가 같은 유닛으로 가는 곳이 몇 군데 있다.

예를 들면 PC에 들어가는 값은 두 개의 덧셈기에서 나온다. (하나는 4가 더해지고, 하나는 Instruction으로부터 나온다.)

ALU의 두번째 입력은 레지스터 혹은 명령어의 immediate 필드에서 나오며, 레지스터 파일에 쓰여질 데이터는 ALU나 Data memory에서 나온다.

> 실제로는 이들을 단순히 연결하는 것이 불가능하기 때문에 `멀티플렉서`를 통해 구현한다.

둘째로 어떤 유닛(장치)들은 명령어 종류에 따라 다르게 제어되어야 한다.

예를 들어 `데이터 메모리`는 `적재` 명령어일 때는 `읽기`, `저장` 명령어일 때는 `쓰기`를 해야 한다.

ALU는 여러 연산(더하기, 곱하기, 나누기, 빼기)들 중 하나를 수행해야 한다.

> 이러한 동작들은 `명령어`의 여러 `필드` 값에 따라 정해지는 `제어선`에 의해 통제된다.

아래 그림은 위의 그림에서 `제어선`과 `멀티플렉서`를 추가한 그림이다.

`제어 유닛(control unit)`은 기능 유닛들과 두 멀티플렉서(우측의 두 개에 해당)의 제어선 값을 결정하는 데 사용하는 것으로, `명령어`를 입력으로 받는다.

이제 위 그림을 하나하나 살펴보며 이해해 보도록 하자.

우선 데이터패스 설계를 시작하기 위해 RISC-V 명령어 종류 각각을 실행하는데 필요한 `주요 구성 요소`들을 살펴보자.

### 명령어를 인출하고 PC를 증가시키는 데이터패스

아래는 `프로그램 카운터(PC)`로써, 현재 명령어의 주소를 가지고 있는 레지스터이다.

아래는 프로그램의 `명령어를 저장`하고, `주소가 주어지면(Instruction address)` 해당 주소에 저장된 명령어를 보내주는 `메모리` 유닛이다.

명령어를 실행하기 위해서는 메모리에서 명령어를 가져오는(fetch) 것으로 시작해야 한다.

다음 `명령어 실행을 준비`하기 위해서 `프로그램 카운터`가 다음 명령어를 가리키도록 `4`만큼 `증가` 시켜야 한다.

PC가 다음 명령어를 가리킬 수 있도록 값을 증가시켜주는 `덧셈기`가 필요한데, 이 덧셈기는 `ALU`를 가지고 쉽게 만들 수 있다.

ALU에서 실행할 수 있는 많은 연산들 중 `덧셈만 사용하도록 제어선을 연결`하면 된다.

이런 ALU는 영구적으로 덧셈기로 만들어며, 다른 ALU 기능(곱하기, 빼기, 나누기)은 수행할 수 엇ㅂ으므로 그림처럼 Add를 붙인다.

위에서 살펴본 세 가지 기본 유닛들을 합쳐 명령어를 인출하고, PC를 증가시켜 다음 명령어의 주소를 구하는 데이터패스를 만들면 아래와 같다.

### R 형식 명령어의 데이터패스

모든 `R형식` 명령어들은 `2개의 레지스터`를 읽고, 해당 값들을 통해 `ALU 연산을 수행`하며 그 결과를 레지스터에 쓴다.

> 해당 타입 명령어들을 `R 타입` 명령어 또는 `산술/논리` 명령어라 부른다.

해당 명령어에는 add, sub, and, or 명령어를 포함하고 있다.

프로세서의 범용 레지스터 32개는 `레지스터 파일(register file)` 속에 들어 있다.

레지스터 파일은 레지스터들을 모아 놓은 것으로, 파일 내의 레지스터의 번호를 지정하면 어떤 레지스터라도 읽고 쓸 수 있다.

R 형식 명령어들은 `레지스터 피연산자 3개`를 갖고 있기 때문에, 매 명령어마다 레지스터 파일에서 `두 데이터를 읽고 데이터 하나를 써야`한다.

레지스터에서 데이터를 `읽기` 위해서는 레지스터의 `입력과 출력이 한번`씩 필요하다.
`읽을 레지스터 번호를 지정(Read register)`하는 `입력`과, 레지스터에서 `읽은 값을 내보내는 출력(Read Data)`이다.

데이터를 `쓰기` 위해서는 `입력이 2개` 필요하다.
한 입력은 `레지스터 번호를 지정(Write register)`하고, 다른 입력은 `레지스터에 쓸 데이터 값을 제공(Write data)`한다.

레지스터 파일은 Read register 입력에 제공되는 번호에 해당하는 레지스터의 내용을 `항상 출력`한다.
그러나 쓰기는 `쓰기 제어 신호`에 의해 제어되므로 클럭 에지에서 쓰기가 발생하기 위해서는 해당 제어 신호가 1이 되어야 한다.

따라서 전체적으로 `입력 4개`(레지스터 번호 3개와 데이터 1개)와 `출력 2개`(모두 데이터)가 필요하다.

ALU 에서는 해당 레지스터에서 읽은 두 데이터를 통해 연산을 수행하고 결과를 반환한다.

ALU는 여러 연산을 수행할 수 있지만 명령어에 따라 수행되어야 하는 연산이 정해져 있다. 이를 제어하기 위해 ALU 제어 유닛이 사용되는데 이는 뒤에서 살펴보도록 하자.

### 메모리(l-, S-) 형식 명령어의 데이터패스

ld 명령어와 sd 명령어는 `두 개의 레지스터`와 한 개의 `immediate`를 가진다.
해당 명령어들은 `베이스 레지스터`와 명령어에 포함되어 있는 12비트 `immediate`를 통해 `메모리 주소`를 계산한다.

저장 명령어라면 저장할 값을 레지스터 파일에서 읽어 와야 하며, 적재 명령어라면 메모리로부터 읽어들인 값을 지정된 레지스터에 써야 한다.

따라서 두 명령어 모두 `레지스터 파일`과, 메모리 주소를 계산하는 데 사용될 `ALU`가 필요하다.
또한 12비트 값을 64비트 값으로 `부호확장`하는 유닛이 필요하며, 읽고 쓸 데이터 `메모리`가 필요하다.

데이터 메모리는 `저장 명령`일 때만 `쓰기`를 해야 한다.
따라서 데이터 메모리는 `읽기 제어 신호`와 `쓰기 제어 신호`, `주소 입력`, 메모리에 쓸 `데이터 입력`이 필요하다.

(읽기 제어 신호는 올바르지 않은 주소의 값을 읽는 것을 방지하기 위해 필요하다.)

### 분기 명령어의 데이터패스

분기 명령어(beq)는 3개의 피연산자를 갖는데, 2개의 레지스터와 12비트의 offset이다.

2개의 레지스터는 같은지 비교될 피연산자이며, 12비트 offset은 분기 명령어의 주소에 대한 상대적인 `분기 목적지 주소`를 계산하는 데 사용되는 값이다.

이 명령어를 구현하기 위해서는 PC 값에다가 offset 필드를 부호확장한 값을 더해서 분기 목적지 주소를 계산해야 한다.

분기 명령어에서는 주의해야 할 저이 두 가지 있는데 다음과 같다.

> 분기 주소 계산의 베이스 주소는 분기 명령어 주소이다.
> 변위 필드는 하프워드 변위이므로, 왼쪽으로 1비트만큼 자리이동 하여야 한다.

분기 목적지 주소를 계산하는 것 외에도, 분기 명령어는 두 피연산자 레지스터가 동일한지의 여부를 통해 next instruction으로 받아올 주소가 달라진다.

두 피연산자 값이 같을 때 분기 목적지 주소가 새로운 PC 값이 되며, 이때 `분기가 일어났다(taken)`라고 말한다.

반대로 두 피연산자 값이 다를 때에는 다른 명령어와 동일하게 PC의 값이 4 증가되며, 이 값이 새로운 PC 값이 된다.
이 경우에는 `분기가 일어나지 않았다(not taken)`라고 한다.

따라서 분기 데이터패스는 `분기 목적지 주소를 계산`하고, `레지스터 내용을 비교`하는 두 가지 일을 해야 한다.
레지스터 내용의 비교는 ALU를 통해 이루어지며, 뺄셈을 하도록 만드는 `제어 신호`를 ALU에 함께 보낸다.

ALU는 연산 결과가 0인지를 연산의 종류에 관계없이 항상 출력하지만, 앞으로 해당 Zero 신호의 사용은 조건부 분기 명령어의 같은지으 비교 테스트를 구현하기 위해서만 사용하도록 하겠다.

### 데이터패스 유닛 공유

위에서 살펴본 데이터패스 구성 요소들을 하나로 묶고 여기에 제어를 추가하여 데이터패스의 구현을 완성할 수 있다.
우리가 살펴볼 데이터패스는 모든 명령어가 한 클럭 사이클에 실행되도록 할 것이므로, 어느 데이터패스 자원도 명령어 당 두 번 이상 사용될 수 없다.

따라서 두 번 이상 사용할 필요가 있는 구성 요소는 필요한 만큼 여러 개를 두어야 한다.

그러므로 데이터 메모리와 별도로 명령어 메모리가 필요하다. (이들은 명령어 캐시와, 데이터 캐시로 분리되어 제공된다.)

몇몇 기능 유닛은 여러 개를 사용할 필요가 있지만, 많은 구성 요소들이 서로 다른 명령어 흐름들이 공유하여 사용할 수 있다.

여러 명령어 종류에서 데이터패스 구성 요소들을 공유하기 위해서는 그 구성 요소의 입력으로 여러 연결을 허용해야 하며, 멀티플렉서와 제어 신호를 사용하여 그 입력들 중 하나를 사용해야 한다.

아래는 이들을 모두 합쳐 만든 전체 데이터패스이다.
