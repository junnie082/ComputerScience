# 파이프 라인(Pipeline)

#### 2024.12.09.(목)

## [[컴퓨터 구조] 파이프라인(Pipeline)](https://jyukki.tistory.com/19)

### 단일 사이클

`한 클럭` 동안 `하나의 명령어`를 수행한다.

> 가장 길게 실행되는 명령어가 한 클럭의 기준이 된다.

lw = 가장 길다.

Instruction Memory -> register file -> ALU -> MEM -> register file

=

다른 명령어가 빨리 끝나더라도 클럭 시간이 줄어들지 않는다.

설계원칙 3, 자주 일어나는 일을 빠르게

원칙에 어긋난다.

### 단일 사이클 구현은 오늘날 왜 사용되지 않는가?

> 단일 사이클 구현

클럭 사이클이 모든 명령어에 대해 같은 길이를 갖는다.

클럭 사이클이 너무 길다 = 비효율

<-> 파이프라이닝: 여러 명령어가 중첩되어 실행

### 파이프라인 (Pipeline)

파이프라인은 `병렬 처리 방식`이라고 말할 수 있다.

세탁, 탁수, 옷 개기, 옷장에 넣기를 세탁의 `한 사이클`이라고 생각하자.
`단일 사이클`의 경우 한 사이클이 끝나야 다음 세탁물을 세탁할 수 있다.

그러나 `파이프라인`을 사용한다면, 세탁이 끝나 놀고 있는 세탁기에 다음 세탁물을 세탁함으로써 `여러 행동을 중첩해서 실행`할 수 있게 된다.

### MIPS 파이프라인

> MIPS의 파이프라인은 5단계로 구성되어 있다.

1. IF(Instruction Fetch)
   : 메모리에서 명령어를 가져옴

2. ID(Instruction Decode)
   : 명령어를 읽고/해독, 레지스터를 읽음.
   : MIPS 명령어는 형식이 규칙적이어서 읽기/해독이 동시에 일어난다.

3. EX(Execute)
   : 연산 수행 or 주소 계산

4. MEM (Memory aecces)
   : 데이터 메모리에 있는 피연산자의 접근

5. WB(Writeback)
   : 결과값을 레지스터에 쓴다.

### MIPS

MIPS (Microprocessor without interlocked pipeline stage)는

그 이름에서 찾아볼 수 있듯이 파이프라인 실행을 위해 설계되었다.

1. 모든 MIPS 명령어의 길이가 같다.
   IF 단계에서 명령어를 가져오고 ID 단계에서 해독하는 것을 훨씬 쉽게 해준다.

2. 명령어의 형식이 몇 가지 되지 않는다.
   명령어끼리 레지스터의 위치가 같아 ID 단계에서 명령어 읽고/해독 레지스터 읽기를 같이 수행할 수 있다.

3. load와 store 명령어에서만 메모리를 사용한다.
   메모리에 있는 피연산자에서 바로 연산수행이 가능했다면 EX, MEM 단계가 주소단계, 메모리단계, 실행단계로 확장되어야 했을 것이다.

4. 피연산자가 메모리에 정렬되어 있으므로 메모리에 두 번 접근할 이유가 없다.
