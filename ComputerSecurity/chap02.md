# Computer Security

# Chap02 사용자인증

#### 2024.09.22.(일)

## 목차

1. 사용자 인증 개요
2. 비밀번호 기반 인증
3. 토큰 기반 인증
4. 생체 인식 인증
5. 원격 사용자 인증
6. 인증 보안 이슈

## 1. 사용자 인증 개요

### 사용자 인증 정의

- 시스템에 접근하는 자격에 대해 신원을 확인하는 절차
  - RFC 2828

### 인증절차

- 인증은 정보보안의 근본적인 요소이며 주된 핵심

- 접근 제어 및 사용자 책임 기반

- 신원 확인 단계

  - 식별자가 보안 시스템에 자신의 신분을 제시

- 입증 단계
  - 개체와 식별자간의 유대를 증명하는 인증 정보를 제시 혹은 생성

### 사용자 인증의 4가지 유형

| 유형 | 수단 | 기술 |
| 지식기반 | 알고 있는 것을 통한 인증 (Something you know) | 비밀번호, PIN, 질문에 대한 응답 |
| 소유기반 | 소유물을 통한 인증 (Something you have) | 토큰, 스마트 카드, 전자 키 카드, OTP, 공인인증서, 휴대폰 SMS |
| 생체기반 | 생체 조직을 통한 인증 (Something you are) | 지문, 망막, 홍채, 얼굴, 정맥 |
| 특징기반 | 행동을 통한 인증 (Something you do) | 목소리 패턴, 필적, 타이핑 리듬, 서명, 걸음걸이 |

### 전자 사용자 인증 원리

- 사용자 인증 정의

  - 전자 인증 (Electronic Authentication, EA): 전자 사용자 인증을 정보 시스템에 전자적으로 제시된 사용자 식별자들에 대한 신뢰성 수립 과정 (Electronic Authentication Guideline, NIST SP 800-63-2)
    . 2013년 공표, 2017.6 취소됨
    -> NIST SP 800-63-3 Special Publication: Digital Identity Guidelines 공표, 2017.6

  - 시스템은 인증된 개인이 데이터베이스 트랜잭션이나 시스템 자원에 대한 접근 같은 특정 기능 수행에 대한 권한을 결정하는데 인증된 식별자를 사용

  - 전자인증(EA)은 `디지털 인증 (Digital Authentication)` 로 용어 변경 사용됨, NIST SP 800-63-3 Special Publication

  ```
  The process of establishing confidence in user identities presented digitally to a system. In previous editions of SP 800-63, this was referred to as Electronic Authentication.
    - Digital Identity Guidelines, NIST Special Publication 800-63-3
  ```

### 사용자 인증의 일반적 모델

- NIST SP 800-63-2

등록, 신용장 발급, 관리

1. 신분 증명, 사용자 등록
   등록기관 (RA) <-> 가입자 (신청자)

2. 토큰, 신용장 등록/발급
   신용장 서비스 공급자 (CSP) <-> 가입자 (신청자)

3. 인증된 프로토콜 교환
   청구자 <-> 검증자

4. 토큰/신용장 확인
   신용장 서비스 공급자 (CSP) <-> 검증자

5. 인증 요구/확인
   의뢰자 (RP, application) <-> 검증자

6. 인증된 세션
   청구자 <-> 의뢰자 (RP, application)

### 인증모델 절차 설명

- `신청자`는 등록기관의 신용장 서비스 제공자에게 가입을 신청

  - 등록기관 (Registration Authority, RA): 신용장 서비스 제공자에게 신청자의 신원을 보증하는 신뢰할 수 있는 존재
  - 신용장 (Credential Service): 식별자 (Identifier)와 가입자 (Subscriber) 가 소유한 토큰의 속성에 부여된 자료 구조이며, 인증 트랜잭션 내의 검증자가 검증
    - 토큰: 암호키 혹은 가입자를 식별할 수 있는 암호화된 비밀번호

- 신용장 서비스를 위해 제공자는 가입자와 정보를 교환
- 전체 인증 시스템의 세부사항에 따라 신용장 서비스 제공자는 여러 전자 신용장을 가입자에게 발급
- 사용자가 가입자로 등록되면 실제 인증 과정이 가입자와 단수 혹은 복수의 시스템 사이에서 발생

- `청구자`와 `검증자`

  - 청구자 (Claimant): 인증을 받고자 하는 자
    - 인증 프로토콜을 통해 검증자에게 성공적으로 토큰의 제어와 소유를 제시
  - 검증자 (Verifier): 식별을 인증하는 쪽
    - 청구자가 신용장의 가입자임을 검증
    - 검증자는 가입자의 신원에 대한 확인증을 의뢰자에게 전달
      - 확인증: 가입자 이름, 등록 시 부여된 식별자, 혹은 등록 시 검증된 가입자 속성 같은 가입자 식별 정보 등 포함

- 의뢰자 (RP)

  - 검증자가 제공하는 인증된 정보를 접근 제어나 인증결정에 사용할 수 있음
  - 신뢰기관, 식별자 등이 고려될 수 있음

- Digital Identity Guidelines - Digital Identity Model
  - NIST Special Publication 800-63-3

Enrollment and Identity Proofing

## 2. 비밀번호 기반 인증

### 비밀번호 기반 인증

- 일반적으로 널리 알려진 침입자 방지 수단

  - 비슷한 서비스들이 사용자에게 이름이나 식별자(ID) 뿐만 아니라 비밀번호를 요구
  - 시스템은 시스템 안에 저장된 비밀번호 파일의 사용자 ID와 대응되는 비밀번호를 입력된 비밀번호와 비교

- 비밀번호 기반의 인증 시스템은 사용자 ID로 표시되는 비밀번호 파일을 가짐

  - ID는 다음과 같은 방식으로 보안을 제공
    - ID는 사용자가 시스템에 접근이 허가되었는지 결정
    - ID는 사용자 권한을 결정함
    - ID는 임의 접근 제어(discretionary access control)로서 사용
      예) ID 목록에 있는 일반 사용자가 관리자 소유의 파일을 읽을 수 있는 권한을 부여 받은 경우

- 사용자의 비밀번호 대신 일방향 해시 함수를 사용하여 비밀번호의 해시값을 저장

### 비밀번호 취약점

- 오프라인 사전 공격
- 단일 사용자에 대한 암호 추측
- 단말기 강탈 하이재킹 공격
- 컴퓨터 감시 (모니터링)
- 특정 계정 공격
- 공공/알려진 암호 공격
- 사용자 실수를 이용한 공격
- 다중 비밀번호 사용을 악용

### 비밀번호 공격기법 및 대응방안

- 오프라인 사전 공격

  - 접근 제어가 시스템의 비밀번호 파일을 보호하는데 사용
  - 공격자 - 시스템 비밀번호 파일을 얻어 흔히 사용되는 비밀번호의 해시 함수값과 비교함. 같은 값이 발견되면, 공격자는 ID/비밀번호 값을 얻을 수 있음
  - 대응책
    .비밀번호 파일에 대한 허가되지 않은 접근 방지
    .타협 방지를 위한 침입 탐지
    .노출된 비밀번호에 대한 빠른 재발급

- 특정 계정 공격

  - 공격자 - 특정 계정을 목표로 일치하는 비밀번호가 발견될 때까지 비밀번호를 추측하여 입력
  - 대응책: 계정 폐쇄 방법 (일정 시도 횟수를 실패하면 자동 폐쇄)

- 잘 알려진 비밀번호 공격

  - 여러 사용자의 ID에 대해 잘 알려진 비밀번호를 사용해보는 것
  - 사용자는 비밀번호를 쉽게 기억하는 것으로 설정하는 경향 -> 공격자도 비밀번호를 쉽게 추측 가능
  - 대응책: 사용자가 흔한 비밀번호를 선택을 못 하도록 방지하는 정책. 인증 요청을 하는 IP 주소와 사용자 쿠키에 대한 스캐닝을 함

- 단말기 강탈

  - 공격자 - 단말기에 접속한 사람이 자리를 비울 때까지 기다림
  - 대응책: 자동적으로 단말기에 접속하여 일정 시간 작동이 없다면 로그아웃하는 방법. 침입탐지 기법으로 사용자의 행동 변화 탐지

- 단일 사용자에 대한 비밀번호 추측

  - 공격자 - 계정 소유자에 대한 정보와 시스템 비밀번호 정책을 알아내어 비밀번호 추측
  - 대응책: 비밀번호는 추측하기 어렵게 만드는 비밀번호 정책 및 훈련의 강화 필요
    -> 기밀성, 비밀번호 최소 길이, 문자 집합, 잘 알려진 사용자 식별자 사용금지, 비밀번호 사용기간 단축

- 사용자 실수 이용

  - 사용자가 기억을 위해서 비밀번호를 적어 놓았을 경우,
    -> 공격자들 - 사회 공학 전술 등을 사용하여 사용자 혹은 관리자에게 성공적으로 비밀번호 획득 가능
  - 대응책: 사용자 훈련, 침입 탐지, 다른 인증 방법과 결합된 간단한 비밀번호 사용

- 다중 비밀번호 사용

  - 여러 네트워크 장치가 한 사용자에 대해 같은 비밀번호 혹은 비슷한 비밀번호를 사용
    -> 공격자 - 좀 더 효율적인 방법으로 피해를 줄 수 있음
  - 대응책: 각각의 네트워크 장치에서 같거나 혹은 비슷한 비밀번호 사용을 제한하는 정책 사용

- 컴퓨터 모니터링
  - 비밀번호가 네트워크 상에서 원격으로 교환된다면 도청에 취약
  - 간단한 비밀번호 암호화는 도청 및 재사용 때문에 문제 해결책이 될 수 없음
  - 대응책: 보다 강력한 비밀번호 암호화를 사용

### 해시 비밀번호의 사용

- UNIX 및 많은 운영체제에서 가장 널리 사용되는 비밀번호 기술
- 해시(Hash) 비밀번호와 솔트(salt) 값 사용
- 절차
  1. 사용자는 비밀번호를 선택하거나 부여 받음
  2. 비밀번호는 고정된 길이의 솔트값과 함께 조합
  3. 비밀번호와 솔트가 해시 알고리즘의 입력으로 제공되어 고정된 길이의 해시값을 생성
  4. 해시된 비밀번호는 솔트값과 같이 사용자 ID에 상응하는 비밀번호 파일에 저장
  5. 사용자가 UNIX 시스템에 접근을 시도할 때, 사용자는 ID와 비밀번호를 제공
  6. 운영체제는 제공된 ID를 비밀번호 파일의 색인으로 사용, 솔트와 비밀번호를 추출
  7. 솔트와 사용자가 제공한 비밀번호는 암호화 과정의 입력으로 사용
  8. 저장된 값과 일치하면 비밀번호 허용

### UNIX 비밀번호 방식

- 비밀 번호 검증

Password File (: User ID, Salt, Hash code)

User id -> (Select) = User ID

Salt + Password -> slow hash function + Hashed password -> Compare

- 솔트 사용의 목적

1. 비밀번호 파일에서 중복되는 비밀번호를 방지

- 만약 두 명의 사용자가 같은 비밀번호를 선택하더라도, 비밀번호들은 서로 다른 솔트 값을 할당 받으므로 두 명의 사용자의 해시된 배밀번호는 서로 다름

2. 오프라인 사전 공격을 획기적으로 어렵게 만듦

- 길이가 b비트인 솔트에 대해서 가능한 비밀번호이 수는 2^b가 되며, 사전 공격에서 비밀번호 추측의 어려움이 증가

3. 둘 혹은 그 이상의 시스템에서 한 사람에 의해 사용되는 같은 비밀번호를 발견하기는 거의 불가능

### 사용자 선택 비밀번호 크래킹

- 전통적 접근

  - 사전 공격

    - 가능한 비밀번호를 포함한 사전을 만들고 비밀번호 파일에 모두 시도
    - 각 비밀번호를 가능한 솔트 값들로 해시해서 저장된 해시 값과 비교하는 것
    - 찾아내지 못하면, 크래킹 프로그램은 사전 내의 모든 단어의 변형들에 대해서 시도함
    - 변형 - 역방향 철자, 숫자의 추가 또는 특수 기호, 문자의 순서성 등

  - rainbow table 공격

    - 미리 해시 값을 계산하여 저장해놓는 방법
    - 공격자가 가능한 한 많은 비밀번호를 가진 사전을 생성
    - 공격자는 각 비밀번호를 각각의 솔트 값과 관련해서 해시 값을 생성
    - 그 결과가 "rainbow table"이라 알려진 매머드급 해시테이블

  - 비밀번호 크래커

    - 사람들이 추측하기 용이한 비밀번호를 선택한다는 점을 이용
    - 어떤 사용자들은 비밀번호를 고를 때 아주 짧은 것을 선택
    - 간단한 해결책
      .시스템이 6자리 이하의 비밀번호를 거부
      .모든 비밀번호를 8자리로 고정

  - John the Ripper
    - 사전의 전체 단어를 시도해보는 공격에 많이 쓰임
    - 1996년 처음 개발된 오픈 소스 비밀번호 크래커 (패스워드 크래킹 소프트웨어 도구)

- 비밀번호 크래킹 기법의 발전

  - 두 가지 방향으로 향상

    - 1. 비밀번호 크래킹 처리 속도가 놀랍게 향상되었음
    - 2. 비밀번호 크래킹 기법은 잠재적 비밀번호 생성의 정교한 알고리즘을 사용

  - 복잡한 비밀번호 정책을 시행하는 대학교의 학생 2,500명의 비밀번호 분석
    - RockYou 등에서 유출된 실제 비밀번호 파일들을 데이터베이스로 구축
    - 그래프는 비밀번호당 추측 횟수에 따른 백분율을 나타냄
    - 10% 이상의 비밀번호는 10^10 번 추측으로 알아낼 수 있었음
    - 10^13번 추측으로는 40% 이상의 비밀번호를 알아냈음

### 비밀번호 파일 접근 제어

- 비밀번호 공격을 막기 위해 공격자의 비밀번호 파일에 대한 접근 거부

  - 특별한 권한 소유자만 파일의 해시된 비밀번호 접근이 가능
    - 공격자가 사용자의 비밀번호를 알지 못한다면 비밀번호 파일을 읽을 수 없음
    - 해시된 비밀번호는 사용자 ID와 격리되어 "Shadow password file" 역할

- 비밀번호 보호 정책

  - 기술을 바탕으로 한 완벽한 접근 제어 수단과 예측하기 어려운 사용자의 비밀번호 선택을 병행해야 함

- 비밀번호 파일의 취약점들
  - 대부분의 UNIX 시스템을 포함한 많은 시스템들은 예상치 못한 시스템 멈춤에 취약
  - 해커
    - 운영체제의 이러한 소프트웨어 취약점을 이용해 접근 제어 시스템을 우회하여 비밀번호 파일을 추출 가능
    - 파일 시스템 / 데이터베이스 관리 시스템의 취약점을 찾아 파일에 접근 가능
    - 보안 사고 -> 우발적으로 비밀번호 파일을 읽기와 계정의 손상이 발생 가능
    - 몇몇 사용자들은 다른 기억 영역에 다른 기기에 대한 계정을 가지고 있으며, 동일한 비밀번호를 사용함
    - 물리적 보안의 취약점은 해커에게 기회를 제공
    - 비밀번호를 여분의 디스크 또는 기록용 디스크에 위급 상황에 대비해 백업함
      - 이러한 백업을 공격자가 접근하여 비밀번호 파일 공격이 가능함
    - 사용자가 리눅스 같은 다른 OS로 부팅하여 비밀번호 파일에 접근할 수 있음
    - 시스템 비밀번호 파일 대신 네트워크 트래픽 스니핑 같은 다른 접근 방식으로 사용자의 ID와 비밀번호를 수집할 수 있음

### 비밀번호 선택 전략

- 사용자들이 무작위로 선택된 8개의 문자로 구성된 비밀번호를 부여 받는다면 비밀번호 크래킹은 매우 어려움

  - 대부분의 사용자들은 비밀번호를 기억하지 못함

- 목표: 사용자가 기억하기 쉬운 비밀번호를 선택하되 추측하기 쉬운 비밀번호 제거

- 기본적인 네 가지 기술

  - 사용자 교육
  - 컴퓨터에 의한 비밀번호 생성
  - 반응적 비밀번호 확인
  - 복잡한 비밀번호 정책

- 반응적 비밀번호 확인 전략

  - 시스템이 정기적으로 시스템 내부의 비밀번호 크래커를 작동시켜 추측 가능한 비밀번호를 시스템 자체적으로 발견
  - 시스템은 비밀번호가 추측 가능한 것이라면 사용자에게 이를 알리고 재설정 요구
  - 문제점
    - 1. 자원 소비가 큼
      - 비밀번호 파일을 훔칠 수 있는 공격자는 이러한 작업을 위해서 몇 시간 또는 심지어 며칠 동안 최대 CPU 시간을 투자할 수 있기 때문
    - 2. 비밀번호 반응 확인 시스템이 문제점을 발견하기 전까지 취약점이 계속 존재

- 사전적 비밀번호 정책
  - 비밀번호 보안을 향상하기 위한 가장 좋은 접근 방법
  - 사용자가 자신의 비밀번호를 선택할 때 `시스템 허락`을 받도록 하는 방식
  - 사용자에게 충분한 안내와 추측에 의한 사전 공격 가능성이 없는 비밀번호 중에서 사용자가 기억할 수 있는 비밀번호를 선택 유도

### 사전적 비밀번호 정책

- 비밀번호 크래커

  - 사용하지 않는 사전기반으로 암호를 재확인

- 규칙 적용

  - 암호가 준수해야 하는 특정 규칙

- Bloom filter
  - 해시를 사용한 사전 기반으로 테이블을 작성
  - 테이블에 대해 원하는 비밀번호 확인

## 3. 토큰 기반 인증

### 세션기반 인증 vs 토큰기반 인증

- 세션기반 인증

1. 로그인 (user ID & Password)
2. ID/PW 검증
3. 세션 저장
4. 세션 발급 (Set-Cookie: 세션 값)
5. 데이터 요청 (cookie: sessionId = 세션 값)
6. 세션 검증
7. 데이터 조회 및 반환
8. 데이터 응답

- 토큰기반 인증

1. 로그인 (user ID & Password)
2. ID/PW 검증
3. 토큰 전달
4. 데이터 요청 (Authorization: bearer token)
5. 토큰 유효성 검증
6. 데이터 조회 및 반환
7. 데이터 응답

### 토큰 기반 인증

- 토큰: 사용자 인증 목적을 위해 사용자가 소유한 객체

- 토큰으로 사용되는 카드 유형

| 카드 유형 | 특징 | 예 |
| 금형 도안 | 앞면 표지 | 구형 신용카드 |
| 전자기 띠 | 뒷면 전자기 띠, 앞면 문자 | 은행 카드 |
| 메모리 | 메모리 내장 | 선불 전화카드 |
| 스마트, 접촉형, 비접촉형 | 내부 메모리와 프로세서, 표면의 전기적 접촉, 내장된 라디오 안테나 | 생체 ID 카드 |

### 메모리 카드

- 데이터 저장 기능 (처리는 못 함)

  - 예) 뒷면에 전자기 띠 (마그네틱 라인)를 가진 은행 카드, 전자기 띠는 판독기가 읽을 수 있는 간단한 보안 코드만 저장

- 개인 식별 번호 (PIN) 또는 비밀번호와 결합하여 강력한 보안성을 제공

- 잠재적 약점
  - 특수 판독기 필요: 토큰 사용 비용과 판독기의 하드웨어 및 소프트웨어의 보안성 관리가 유지되어야 하는 필요성이 발생
  - 토큰 손실: 토큰을 잃어버린 경우 일시적으로 사용자의 시스템 접근이 제한
  - 토큰이 위조되거나 도용된다면, 공격자는 PIN만 알아내면 접근이 가능
  - 사용자 불만: 사용자가 ATM 사용을 위한 메모리 카드 사용에 어려움이 없더라도, 컴퓨터 접근을 위한 메모리 카드의 사용은 불편한 것으로 간주됨

### 스마트 카드

- 프로세서, 메모리, 입출력 포트를 포함한 전체 마이크로프로세서를 포함

- 스마트 카드

  - 1. 물리적 특징
    - 내장 마이크로 소프트웨어를 포함하고 있는 스마트 토큰, 은행 카드와 비슷한 스마트 토큰은 스마트카드라 불림
  - 2. 사용자 인터페이스
    - 사용자와 토큰 간의 인터페이스는 키패드와 화면이 포함됨
  - 3. 전자적 인터페이스
    - 스마트카드나 다른 토큰들은 호환되는 판독기/기록기와 통신을 위해서 전자적 인터페이스를 요구
    - 인터페이스 유형
      - 1. 접촉형
        - 표면을 스마트카드 판독기에 직접 접촉해야 함
        - 명령어, 데이터, 카드 상태 정보 등은 물리적 접촉면에서 발생
      - 2. 비접촉형
        - 스마트카드 판독기에 가까이 대기만 하면 됨
        - 판독기와 카드는 안테나를 가지고 있으며 라디오 주파수를 통해 교신
        - 대부분의 비접촉형 카드는 전자기적 신호에서 내부 칩을 위한 전원도 전달

- 스마트 토큰을 이용한 인증 프로토콜

1. 정적

- 사용자 - 자신을 토큰에 인증, 토큰 - 사용자를 컴퓨터에 인증

2. 동적 비밀번호 생성기

- 토큰 - 고유의 비밀번호를 주기적으로 생성
- 생성된 비밀번호 - 수동으로 사용자에 의해서 또는 토큰을 통해 인증을 위해 컴퓨터 시스템에 입력
- 토큰과 컴퓨터 시스템 - 초기화 및 동기화가 되어 컴퓨터가 현재 토큰의 비밀번호를 알고 있어야 함

3. 시도 응답

- 컴퓨터 시스템은 랜덤 숫자들로 이루어진 문장 생성
- 스마트 토큰 - 컴퓨터 시스템이 생성한 문장에 대한 응답을 생성

- 스마트 카드의 세 가지 메모리 타입

1. 읽기 전용 메모리 (ROM)

- 카드 번호와 카드 주인의 이름 정보 등이 사용 기간 동안 변하지 않고 저장 유지됨

2. 전기적으로 삭제가 가능하고 프로그래밍이 가능한 ROM (EEPROM)

- 프로토콜 같은 응용프로그램 데이터 및 프로그램만 저장함
- 매 시간 변화하는 데이터를 저장하기도 함
  Ex) 전화카드 안의 EEPROM은 통화 시간을 저장 및 유지함

3. RAM

- 응용프로그램이 실행되는 동안 일시적인 데이터를 저장함

### 스마트 카드/판독기 동작

스마트 카드 | 스마트 단말기

1. <- ATR
2. -> 프로토콜 협상 PTS
3. <- 협상 응답 PTS
4. -> 명령어 APDU
5. 응답 <- APDU

- APDU = Application protocol data unit
- ATR = Answer to reset
- PTS = Protocol type selection

### 전자식별카드

- 전자식별 카드
  - 국가 전자식별 카드(eID)는 운전면허증 같은 다른 국가 ID 카드처럼 정부나 상업적 용도로 사용될 수 있음
  - eID 카드는 다양한 프로그램에서 보다 강력한 신원 증명을 제공함
  - 최근에 개발되어 사용되는 독일의 neuerPersonalausweis: 표면에 인간이 판독할 수 있는 다음 데이터를 포함
    1. 개인 데이터
    - 이름, 생년월일, 주소: 여권과 운전면허증과 같은 형태
    2. 문서 번호
    - 9자리의 고유 카드 식별 문자열
    3. 카드 접근 번호 (CAN)
    - 6자리의 숫자가 표면에 인쇄됨
    - 비밀번호로 사용됨
    4. 기계 판독 영역 (MRZ)
    - 3줄의 인간과 기계가 판독할 수 있는 텍스트
    - 비밀번호로 사용 가능

### 전자 ID [eID]

- eID 기능

  1. ePass

  - 정부의 사용을 위한 기능, 카드 소유자의 신원을 나타내는 계수를 저장
  - 다른 서비스도 ePass를 사용할 수 있으며, ePass 기능은 카드에 구현되어야 함
  - 오프라인 기능

  2. eID

  - 다양한 정부와 상용 응용프로그램에서 일반적인 용도로 사용
  - 인가된 서비스가 카드 소유자의 허가 후 접근할 수 있는 신원 기록을 저장
  - 오프라인과 온라인 서비스에 모두 사용 가능

  3. eSign

  - 선택적 기능이며 개인키와 키를 검증하여 전자 서명을 생성하는 보증서를 저장

- 비밀번호 인증 연결 수립(PACE)
  - eID 카드 내의 비접촉형 RF 칩이 접근 제어 없이 판독되지 않도록 함
  - 온라인 응용프로그램의 경우: 카드 소유자만이 알고 있는 6자리의 PIN을 입력함으로써 접근이 수립
  - 오프라인 응용프로그램의 경우: 카드 뒷면에 인쇄된 MRZ 혹은 앞면에 인쇄된 6자리 카드 접근 번호가 사용

### eID 카드의 전자적 기능과 데이터

| 기능 | 목적 | PACE 비밀번호 | 데이터 | 사용 |
| ePass (의무) | 인가된 오프라인 검사 시스템이 데이터 판독 | CAN, MRZ | 얼굴 사진; 2개의 지문 (선택); MRZ 데이터 | 오프라인 생체 신원 검증을 정부 사용으로 예약 |
| eID (활성화 선택) | 온라인 응용프로그램의 데이터 판독 혹은 기능 접근 | eID PIN | 성; 예명 학위; 생년월일; 출생지; 주소; 커뮤니티 ID; 만료일 | 식별; 나이 검증; 커뮤니티 ID 검증; 제한적 식별(가명) 철회 요청 |
| eID (활성화 선택) | 오프라인 검사 시스템이 데이터를 판독하고 주소와 커뮤니티 ID를 업데이트 | CAN, MRZ | 성; 예명 학위; 생년월일; 출생지; 주소; 커뮤니티 ID; 만료일 | 식별; 나이 검증; 커뮤니티 ID 검증; 제한적 식별 (가명) 철회 요청 |
| eSign (증명 선택) | 인증 기관은 온라인으로 서명 보증 | eID PIN | 서명키; X.509 certificate | 전자 서명 생성 |
| eSign (증명 선택) | 시민은 eSign PIN으로 전자 서명 생성 | CAN | 서명키; X.509 certificate | 전자 서명 생성 |

- eID 사용자 인증

1. 사용자 요청 서비스 (예. 웹 브라우저)
2. 서비스 요청
3. eID 메세지 전송
4. 인증 요청
5. PIN 요청
6. 사용자 PIN 입력
7. 인증 프로토콜 진행
8. 인증 결과 전송
9. 인증 결과 전달
10. 서비스 허가

### JWT (JSON Web Token)

- 현재 토큰 인증에서 가장 많이 사용 (RFC 7519)
- 애플리케이션의 액세스 토큰을 만드는 데 주로 사용
- 데이터들이 JSON 형태로 작성되며, 데이터를 비밀키 또는 공개/개인 키로 서명해 사용
- 사용자에게 발급된 토큰으로 인가된 서버 리소스에 접근가능 및 데이터의 무결성도 확인
- JWT는 헤더 (토큰), 페이로드 (데이터), 서명 (헤더와 페이로드의 서명값) 파트로 구성

- 동작 과정

1. 사용자가 id와 password를 입력하여 로그인  
   Client -> Server

2. 서버는 요청을 확인하고 secret key를 통해 Access token을 발급  
   Server -> Server

3. 클라이언트에 JWT 전달  
   Server -> Client

4. 서비스 요청과 권한을 확인하기 위해 헤더에 JWT 전달  
   Client -> Server

5. JWT 서명을 체크하고 JWT에서 사용자 정보를 확인
   Server -> Server

6. 클라이언트에 요청에 대한 응답 전달  
   Server -> Client

## 4. 생체 인식 인증

### 생체 인식 인증

- 생체 인식 인증 시스템
  - 신체의 특징을 이용한 개인 인증
  - 지문, 손 모양, 얼굴 특성, 망막, 홍채 패턴 등과 같은 정적 특성과 음성과 서명 등과 같은 동적 특성 포함
  - 기본적으로 패턴 인식을 기반으로 함

* 생체 인식 응용프로그램의 물리적 특성

  - 얼굴 특징: 사람과 사람을 구별하는 가장 흔한 방법이므로 컴퓨터에서 식별도 자연스럽게 고려됨

    - 가장 보편적인 접근 방법은 상대적 위치와 눈, 눈썹, 코, 입술, 턱과 같은 주요 얼굴 특징의 모양 등을 기반으로 하는 것임
    - 다른 접근법은 인간의 얼굴을 기본 혈관 시스템과 상호 얼굴 형상을 생산하기 위해 적외선 카메라를 사용하는 방법임

  - 지문: 수 세기 동안 식별을 위한 도구로 사용되어 왔고, 이러한 과정은 체계화 되고 법의 집행 목적에 대해서 부분적으로 자동화됨

    - 산등성이 패턴과 손가락 끝 표면의 밭고랑 패턴으로 이루어짐
    - 자동 지문 인식기와 비교분석 시스템은 모든 지문 인식 패턴 중 수치 대리로 저장하기 위해 지문의 기능 번호를 추출함

  - 손 모양: 모양, 길이, 손가락 너비 등 손의 특징을 구별함

  - 망막 패턴: 망막 표면 바로 아래 혈관에 의해 형성된 패턴은 고유하므로 인증에 적합

    - 망막 인식 시스템은 눈의 시각이나 적외선 빛을 낮은 강도 광선을 추측하여 망막 패턴의 디지털 이미지를 얻음

  - 홍채: 홍채의 세부 구조는 또 다른 독특한 신체적 특징임

  - 서명: 각각의 필기는 독특한 스타일을 가지고 있어, 이것을 이용하여 특히 서명에 반영됨

    - 개인의 여러 서명 샘플이 동일하지 않고 미래의 샘플과 일치시킬 수 있는 서명의 컴퓨터 표현을 구현하는 단계는 복잡함

  - 음성: 개인의 서명 스타일이 쓴 사람의 독특한 신체적 특성뿐만 아니라 습관도 반영됨

    - 한 사람에게 시간에 따라서 다양한 샘플이 존재하며, 생체 인식 작업을 복잡하게 함

  - 셍체인식 인증읭 비용과 정확도의 상관관계 (개략적인 지표)

    - 정확도는 스마트 카드 및 비밀번호 사용자 인증은 적용하지 않음
      - 예) 사용자가 비밀번호를 입력하면, 사용자가 맞는지 아닌지, 입력된 비밀번호와 예상된 비밀번호가 정확히 맞는지 확인함

  - 생체인식 인증 시스템은 입력된 생체 인식 특징과 저장된 특징을 비교 후 인증
    - 생체 인식 정확도 개념 이전의 작동하는지 알아야 함

* 일반적 생체 시스템
  - 사용자 개개인의 생체 인식 정보가 먼저 공인 데이터베이스에 등록되어야 함
  - 데이터베이스 등록은 사용자에게 비밀번호를 할당하는 것과 유사함

#### 생체 정보 등록 절차

사용자 인터페이스 -> 생체센서 -> 특징추출 -> 생체정보 데이터베이스

#### 생체인식 인증 절차

사용자 인터페이스 -> 생체센서 -> 특징 추출 + 생체정보 데이터베이스 = 정보 비교 -> 사용자신원 일치/불일치

- 생체인식기술에 활용되기 위한 일반적으로 갖추어야할 특성

| 특성 | 설명 |
| 보편성(Universality) | 모든 사람이 가지고 있는 생체 특성이 있어야 함 |
| 유일성 (Uniqueness) | 같은 특성을 가진 사람이 없어야 함 |
| 영구성 (Permanence) | 절대 변화하거나 변경되지 않아야 함 |
| 획득성 (Collectability) | 센서로부터 생체 특성 정보 추출 및 정량화가 용이해야 함 |

- 생체 인식 정확도

  - 생체 인식에서는 개인의 물리적 특성은 디지털 정보로 표현되고 개인별로 단일 디지털 표현 혹은 템플릿을 컴퓨터에 저장

  - 사용자가 인증하려 할 때, 시스템은 저장된 정보 집합과 제공된 정보 집합을 비교하게 되고 주어진 복잡한 생체 정보를 사람은 저장된 정보와 정확히 일치하는지 예측할 수 없음

  - 시스템은 일치되는 정보 (matching score, 일반적으로 숫자로 표현)를 생성하는 알고리즘을 이용하여 저장된 정보와 입력된 정보 사이의 유사한 정도를 측정
    - 허위 일치 비율 (false match rate): 같은 출처의 생체 샘플이 제대로 인식되는 횟수와 다른 출처로 오인되는 횟수의 비율
    - 허위 불일치 비율 (false non-match rate): 같은 출처의 샘플이 다른 출처로 오인되는 비율

  * 오인식률(FAR: False Acceptance Rate): 본인의 것이 아닌 생체인식 정보를 본인의 것으로 잘못 판단할 확률
  * 오거부률(FRR: False Rejection Rate): 본인의 생체정보를 본인이 아닌 것으로 잘못 판단할 확률

- 생체인식 인증 시스템의 딜레마

  - 한 사용자가 여러 번 시스템에 의해서 인증
    - 일치되는 정도 (matching score) s값은 다양하게 측정되어 확률 밀도 함수는 종 모양을 띠게 됨
    - 예) 지문 인식에서, 결과 값은 센서 잡음, 측정 시 손가락 팽창 정도, 건조한 상태 정도, 손가락 배치 위치 등으로 인해 추출된 값이 변하게 됨
    - 평균적으로 추출된 결과값은 일치되는 정도가 같고, 재측정을 할수록 확률 밀도 함수는 종 모양 형태를 띠게 됨
      -> 주어진 진짜 정보와 거짓 정보 집합 범위 안에서 제공된 정보를 비교하는 것이 매우 어려움

- 이상적인 생체 인식 측정 운영특성 곡선

  - 생체 인식 시스템의 허위 일치 범위와 허위 불일치의 대조된 양상으로 구성
  - 서로 다른 두 시스템에 대한 이상적인 곡선, 곡선이 낮고 왼쪽일수록 이상적임

- 실제 제품 테스트에서 얻은 특성 곡선
  - `홍채 인식` 시스템은 200만 이상의 상호 비교에서 허위 일치 비율이 없으며 넓은 허위 일치 비율에 대해 얼굴 생체 인식은 최악의 성능을 보임

## 5. 원격 사용자 인증

### Challenge-Response 개인식별 프로토콜

- 시도-응답 개인식별 프로토콜
- Client와 Server가 공통된 secret key K를 공유
- E is a public encryption function e.g. DES; hash function
- 비밀정보(secret information)의 상호교환은 없음
- key database 보호
- 매번 상이한 Response 값; E 함수의 안정성에 기반

1. Identity 제시, "I am Alice"  
   Client -> Server

2. a Challenge, r  
   Server -> Client

3. a Response, EK(r)  
   Client -> Server

### 비밀번호 프로토콜

- 비밀번호를 통한 간단한 시도-응답 프로토콜의 예
  - 사용자: 자신의 신분을 증명할 수 있는 정보를 원격 호스트로 보냄
  - 원격 호스트: 일회성 랜덤 숫자 (nonce) 생성, 이 값을 사용자에게 전송
    - 호스트 쪽에선 두 함수 h()와 f()를 명시하여 전송
  - 사용자의 응답: f(r', h(P'))을 계산한 값
    - r'=r, P': 사용자의 비밀번호, h(): 해시 함수
  - 비밀번호와 함수 f를 통해 생성한 랜덤 숫자를 조합한 값을 해시 연산 값으로 출력
  - 호스트: 등록된 사용자 비밀번호를 해시함수를 이용해서 저장
  - 사용자 U: h(P(U))으로 표현
  - 사용자로부터 응답이 오면, 호스트는 f(r', h(P'))값과 계산된 f(r, h(P(U))) 값을 비교하여 값이 일치하면 사용자 인증 성공

| Client | | Host |
| U, User | -> U | r, random number. h(), f(), functions |
| P'. r', return of r | <- (r, h(), f()) | r, random number. h(), f(), functions |
| P'. r', return of r | -> f(r', h(P')) | if f(r', h(P')) = f(r, h(P(U))) then yes else no |
| | <- yes/ no | |

### 토큰 프로토콜

- 토큰 기반 인증 프로토콜 예
  - 사용자: 자신의 신분을 증명할 수 있는 정보를 원격 호스트로 전송
  - 호스트: 무작위로 선정한 숫자와 식별함수 f()와 h()를 사용한 응답
  - 토큰: 정적 패스코드를 저장하거나 일회성으로 무작위 패스코드를 생성
    - 일회성 무작위 생성 패스코드 - 어떤 방식으로든 호스트 쪽과 서버 쪽의 동기화가 이루어져야 함
    - 예) 사용자가 비밀번호 P'를 입력하여 패스코드를 활성화 시키는 방법
  - 비밀번호: 사용자와 토큰 사이에서만 공유, 원격호스트는 제외
  - 토큰 f(r', h(W'))으로 호스트에 응답,
    - 정적 패스코드 - 원격호스트 쪽에서 h(W(U))의 해시 연산된 값을 저장
    - 동적 패스코드 - 원격호스트가 일회성 패스코드를 생성하고 해시 값을 가짐

| Client | | Host |
| U, User | -> U | r, random number. h(), f(), functions |
| P' -> W' password to passcode via token r', return of r | <- (r, h(), f()) | r, random number. h(), f(), functions |
| P' -> W' password to passcode via token r', return of r | -> f(r', h(W')) | if f(r', h(W')) = f(r, h(W(U))) then yes else no |
| | <- yes/ no | |

### 정적 생체 인식 프로토콜

- 정적인 생체정보를 통한 프로토콜의 예
  - 사용자: ID를 호스트에게 전송
  - 호스트: 무작위로 선정한 숫자 r과 암호화를 위한 E()의 식별자를 사용자에게 전송
  - 사용자측, 클라이어트 시스템에서는 생체 인식 장치를 제어
    - 사용자의 생체 인식 B'로부터 생체 인식 정보 집합인 BT'를 생성, 암호문 E(r', D', BT')를 반환
    - D' 식별자: 특정 생체 인식 장비를 식별할 수 있는 인수
  - 호스트: 사용자로부터 들어오는 메세지를 복호화하여 세 번째 인자를 확인하여 호스트 쪽에 저장된 값과 비교
    - 일치한다면, 호스트는 r' = r을 확인
    - BT'값과 저장된 값 사이의 일치되는 정도를 확인하여 미리 정의된 임계값을 초과하는지 확인
  - 호스트: 호스트 데이터베이스에 등록된 기기목록의 수신장치 ID를 비교하여 생체인식 캡쳐 장치의 간단한 인증은 제공

| Client | | Host |
| U, User | -> U | r, random number. E(), function |
| B' -> BT' biometric D' biometric device r', return of r | <- (r, E()) | r |
| | -> E(r', D', BT') | E^-1 E(r', P', BT') = (r', P', BT') if r' = r AND D' = D AND BT' = BT(U) then yes else no |
| | <- yes/ no | |

### 동적 생체 인식 프로토콜

- 동적인 생체 인식 프로토콜의 예

  - 정적 생체 인식과 주요 차이점: 인증 시 호스트가 임의의 숫자뿐만 아니라 임의의 순서까지 제공

    - 순서인증: 숫자 순서, 문자 순서, 또는 단어 순서
    - BS'(x') 생성: 클라이언트에서 사용자는 순서를 입으로 소리 내고, 순서를 타이핑, 또는 손으로 써서 생체 인식신호

  - 클라이언트에서는 받은 메세지를 복호화

  - 숫자 r'과 호스트 쪽에서 생성한 r과 일치하는지 확인

  - 생체 인식 정보 BS(x')를 바탕으로 저장된 BT(U)와 비교하여 사용자와 x값이 각각 일치하는지 확인

  - 비교 값이 미리 정의한 임계 값을 초과하면 사용자 인증 성공

| Client | | Host |
| U, User | -> U | r, random number. x, random sequence challenge E(), function |
| | <- (r, x, E()) | B', x' -> BS'(x') r', return of r |
| | -> E(r', BS'(x')) | E^-1 E(r', BS'(x')) = (r', BS'(x')) extract B' from (r', BS'(x')) extract B' from (r', BS'(x')) if r' = r AND x' = x AND B' = B(U) then yes else no |
| | <- yes/ no | |

## 6. 인증 보안 이슈

### 사용자 인증의 일반적인 공격과 방어

| 공격 | 인증자 | 예 | 통상적 방어 |
| 클라이언트 공격 | 비밀번호 | 전수 검색 | 시도 제한, 많은 후보자군 |
| | 토큰 | 전수 검색 | 시도 제한, 많은 후보자군 |
| | 생체 | False match | 시도 제한, 많은 후보자군 |
| 호스트 공격 | 비밀번호 | 평문 도난, 사전적/전수 검색 | 해시; 많은 후보자군, 비밀번호 데이터베이스 보호 |
| | 토큰 | 비밀번호 도난 | 위와 같음; 1회용패스워드 |
| | 생체 | 템플릿 도난 | 장비 인증 캡처; 시도 응답 프로토콜 |
| 도청, 도난, 복사 | 비밀번호 | shoulder surfing | 사용자의 비밀 유지 노력: 문제 있는 비밀번호에 대한 관리자의 빠른 대응; 다중 요소 인증 |
| | 토큰 | 하드웨어 도난, 위조 | 다중 요소 인증; 위조 변조 방지 |
| | 생체 | 생체 복제(스푸핑) | 동적 패턴 변화 분석, 생체특성분석 |
| 재생(재사용) | 비밀번호 | 도난 된 비밀번호 응답재생 | 시도 응답 프로토콜 |
| | 토큰 | 도난 된 비밀번호 응답재생 | 시도 응답 프로토콜; 1회용패스워드 |
| | 생체 | 도난 된 생체 템플릿 응답 재생 | 시도 응답 프로토콜 이용 복사 탐지 |
| 트로이 목마 | 비밀번호, 토큰, 생체 | 가짜 클라이언트 생성 및 장비 도난 | 신뢰하는 보안 영역에서 클라이언트와 장비 인증 |
| 서비스 거부 | 비밀번호, 토큰, 생체 | 다수의 오류인증으로 인한 잠김 | 행위 기반 대응; 실시간 모니터링 - 탐지 및 차단 |

### FIDO 인증 기술

- FIDO (Fast IDentity Online) 바이오 인증 기술
- FIDO Alliance
- FIDO 얼라이언스가 추구하는 인증방식
  - 온라인상의 빠른 신원 확인을 위해 간단하고 (Simpler), 강력한 (Stronger) 인증방식을 개발
  - 최근 카드 결제, 금융거래, 사용자 인증 강화 및 편의성 향상이 필요한 핀테크 비즈니스, 회사 내부결제 등 사용
- FIDO 2.0
  - 모바일뿐만 아니라 PC 환경을 포함한 모든 온라인 환경에서 생체 인증을 사용할 수 있도록 하는 기술  
    (FIDO 1.0: 모바일 환경에서 생체 인증을 사용할 수 있는 표준)
- IoT 디바이스를 위한 자동화된 온보딩 프로토콜 발표, 2001

### FIDO의 두 가지 프로토콜

- UAF (Universal Authentication Framework) Protocol

  - 사용자의 디바이스에서 제공하는 인증 방법을 온라인 서비스와 연동하여 사용자를 인증하는 기술
  - Authenticator 가 기기에 포함

- U2F (Universal 2nd Factor) Protocol
  - 기존 패스워드를 사용하는 온라인 서비스에서 두번째 인증요소로 강한 인증을 사용자 로그인 시에 추가할 수 있는 프로토콜
  - Authenticator 가 기기에 포함되지 않음

### DIDs (디지털 신원 증명) 기술

- 탈중앙 식별자 (Decentralized IDentifiers)

  - 분산 원장 기술 또는 네트워크에 등록되어 있어 중앙집중 형 등록 기관을 필요로 하지 않는 전 세계적 유일한 식별자
  - 중앙기관이 아닌 개인이 자신의 데이터를 직접 관리하는 구조로 기존 방식과 달리 서비스 이용과정에서 모든 개인정보를 제공하지 않음

- 중요 특성

  - 영속성 (Persistent): 변경 및 조작되지 않음
  - 해석가능성 (Resolvable): 메타데이터로 조회할 수 있음
  - 암호학적 증명 (Cryptographically verifiable): 암호학적으로 소유권을 증명할 수 있음
  - 탈중앙성 (Decentralized): 중앙화된 기관이 필요하지 않음

- W3C (World Wide Web Consortium)가 주도하여 블록체인을 이용한 ID인증 구조 논의 시작
  - DID Document Syntax를 정의하고 오픈소스화

### DID 서비스 흐름

- 누구의 소유도 아닌 블록체인에서 탈중앙화 식별자 DID가 관리되고, 누구나 이를 확인할 수 있음

1. 신원인증기관 DID 등록 -> DIDs
2. 신원주 DID 등록
3. \*Claim 요청
4. \*Verifiable Claim 발급
5. Verifiable Claim 제출
6. 블록체인 검증
7. 서비스 접근허가

- Claim: 신원주가 제출한 주민등록번호, 성별 등의 신원정보에 대한 주장
- Verifiable Claim: 신원인증기관에 의해 인증되어 증명 가능한 신원 단위
