# Computer Security

# Chap02 사용자인증

#### 2024.09.22.(일)

## 목차

1. 사용자 인증 개요
2. 비밀번호 기반 인증
3. 토큰 기반 인증
4. 생체 인식 인증
5. 원격 사용자 인증
6. 인증 보안 이슈

## 1. 사용자 인증 개요

### 사용자 인증 정의

- 시스템에 접근하는 자격에 대해 신원을 확인하는 절차
  - RFC 2828

### 인증절차

- 인증은 정보보안의 근본적인 요소이며 주된 핵심

- 접근 제어 및 사용자 책임 기반

- 신원 확인 단계

  - 식별자가 보안 시스템에 자신의 신분을 제시

- 입증 단계
  - 개체와 식별자간의 유대를 증명하는 인증 정보를 제시 혹은 생성

### 사용자 인증의 4가지 유형

| 유형 | 수단 | 기술 |
| 지식기반 | 알고 있는 것을 통한 인증 (Something you know) | 비밀번호, PIN, 질문에 대한 응답 |
| 소유기반 | 소유물을 통한 인증 (Something you have) | 토큰, 스마트 카드, 전자 키 카드, OTP, 공인인증서, 휴대폰 SMS |
| 생체기반 | 생체 조직을 통한 인증 (Something you are) | 지문, 망막, 홍채, 얼굴, 정맥 |
| 특징기반 | 행동을 통한 인증 (Something you do) | 목소리 패턴, 필적, 타이핑 리듬, 서명, 걸음걸이 |

### 전자 사용자 인증 원리

- 사용자 인증 정의

  - 전자 인증 (Electronic Authentication, EA): 전자 사용자 인증을 정보 시스템에 전자적으로 제시된 사용자 식별자들에 대한 신뢰성 수립 과정 (Electronic Authentication Guideline, NIST SP 800-63-2)
    . 2013년 공표, 2017.6 취소됨
    -> NIST SP 800-63-3 Special Publication: Digital Identity Guidelines 공표, 2017.6

  - 시스템은 인증된 개인이 데이터베이스 트랜잭션이나 시스템 자원에 대한 접근 같은 특정 기능 수행에 대한 권한을 결정하는데 인증된 식별자를 사용

  - 전자인증(EA)은 `디지털 인증 (Digital Authentication)` 로 용어 변경 사용됨, NIST SP 800-63-3 Special Publication

  ```
  The process of establishing confidence in user identities presented digitally to a system. In previous editions of SP 800-63, this was referred to as Electronic Authentication.
    - Digital Identity Guidelines, NIST Special Publication 800-63-3
  ```

### 사용자 인증의 일반적 모델

- NIST SP 800-63-2

등록, 신용장 발급, 관리

1. 신분 증명, 사용자 등록
   등록기관 (RA) <-> 가입자 (신청자)

2. 토큰, 신용장 등록/발급
   신용장 서비스 공급자 (CSP) <-> 가입자 (신청자)

3. 인증된 프로토콜 교환
   청구자 <-> 검증자

4. 토큰/신용장 확인
   신용장 서비스 공급자 (CSP) <-> 검증자

5. 인증 요구/확인
   의뢰자 (RP, application) <-> 검증자

6. 인증된 세션
   청구자 <-> 의뢰자 (RP, application)

### 인증모델 절차 설명

- `신청자`는 등록기관의 신용장 서비스 제공자에게 가입을 신청

  - 등록기관 (Registration Authority, RA): 신용장 서비스 제공자에게 신청자의 신원을 보증하는 신뢰할 수 있는 존재
  - 신용장 (Credential Service): 식별자 (Identifier)와 가입자 (Subscriber) 가 소유한 토큰의 속성에 부여된 자료 구조이며, 인증 트랜잭션 내의 검증자가 검증
    - 토큰: 암호키 혹은 가입자를 식별할 수 있는 암호화된 비밀번호

- 신용장 서비스를 위해 제공자는 가입자와 정보를 교환
- 전체 인증 시스템의 세부사항에 따라 신용장 서비스 제공자는 여러 전자 신용장을 가입자에게 발급
- 사용자가 가입자로 등록되면 실제 인증 과정이 가입자와 단수 혹은 복수의 시스템 사이에서 발생

- `청구자`와 `검증자`

  - 청구자 (Claimant): 인증을 받고자 하는 자
    - 인증 프로토콜을 통해 검증자에게 성공적으로 토큰의 제어와 소유를 제시
  - 검증자 (Verifier): 식별을 인증하는 쪽
    - 청구자가 신용장의 가입자임을 검증
    - 검증자는 가입자의 신원에 대한 확인증을 의뢰자에게 전달
      - 확인증: 가입자 이름, 등록 시 부여된 식별자, 혹은 등록 시 검증된 가입자 속성 같은 가입자 식별 정보 등 포함

- 의뢰자 (RP)

  - 검증자가 제공하는 인증된 정보를 접근 제어나 인증결정에 사용할 수 있음
  - 신뢰기관, 식별자 등이 고려될 수 있음

- Digital Identity Guidelines - Digital Identity Model
  - NIST Special Publication 800-63-3

Enrollment and Identity Proofing

## 2. 비밀번호 기반 인증

### 비밀번호 기반 인증

- 일반적으로 널리 알려진 침입자 방지 수단

  - 비슷한 서비스들이 사용자에게 이름이나 식별자(ID) 뿐만 아니라 비밀번호를 요구
  - 시스템은 시스템 안에 저장된 비밀번호 파일의 사용자 ID와 대응되는 비밀번호를 입력된 비밀번호와 비교

- 비밀번호 기반의 인증 시스템은 사용자 ID로 표시되는 비밀번호 파일을 가짐

  - ID는 다음과 같은 방식으로 보안을 제공
    - ID는 사용자가 시스템에 접근이 허가되었는지 결정
    - ID는 사용자 권한을 결정함
    - ID는 임의 접근 제어(discretionary access control)로서 사용
      예) ID 목록에 있는 일반 사용자가 관리자 소유의 파일을 읽을 수 있는 권한을 부여 받은 경우

- 사용자의 비밀번호 대신 일방향 해시 함수를 사용하여 비밀번호의 해시값을 저장

### 비밀번호 취약점

- 오프라인 사전 공격
- 단일 사용자에 대한 암호 추측
- 단말기 강탈 하이재킹 공격
- 컴퓨터 감시 (모니터링)
- 특정 계정 공격
- 공공/알려진 암호 공격
- 사용자 실수를 이용한 공격
- 다중 비밀번호 사용을 악용

### 비밀번호 공격기법 및 대응방안

- 오프라인 사전 공격

  - 접근 제어가 시스템의 비밀번호 파일을 보호하는데 사용
  - 공격자 - 시스템 비밀번호 파일을 얻어 흔히 사용되는 비밀번호의 해시 함수값과 비교함. 같은 값이 발견되면, 공격자는 ID/비밀번호 값을 얻을 수 있음
  - 대응책
    .비밀번호 파일에 대한 허가되지 않은 접근 방지
    .타협 방지를 위한 침입 탐지
    .노출된 비밀번호에 대한 빠른 재발급

- 특정 계정 공격

  - 공격자 - 특정 계정을 목표로 일치하는 비밀번호가 발견될 때까지 비밀번호를 추측하여 입력
  - 대응책: 계정 폐쇄 방법 (일정 시도 횟수를 실패하면 자동 폐쇄)

- 잘 알려진 비밀번호 공격

  - 여러 사용자의 ID에 대해 잘 알려진 비밀번호를 사용해보는 것
  - 사용자는 비밀번호를 쉽게 기억하는 것으로 설정하는 경향 -> 공격자도 비밀번호를 쉽게 추측 가능
  - 대응책: 사용자가 흔한 비밀번호를 선택을 못 하도록 방지하는 정책. 인증 요청을 하는 IP 주소와 사용자 쿠키에 대한 스캐닝을 함

- 단말기 강탈

  - 공격자 - 단말기에 접속한 사람이 자리를 비울 때까지 기다림
  - 대응책: 자동적으로 단말기에 접속하여 일정 시간 작동이 없다면 로그아웃하는 방법. 침입탐지 기법으로 사용자의 행동 변화 탐지

- 단일 사용자에 대한 비밀번호 추측

  - 공격자 - 계정 소유자에 대한 정보와 시스템 비밀번호 정책을 알아내어 비밀번호 추측
  - 대응책: 비밀번호는 추측하기 어렵게 만드는 비밀번호 정책 및 훈련의 강화 필요
    -> 기밀성, 비밀번호 최소 길이, 문자 집합, 잘 알려진 사용자 식별자 사용금지, 비밀번호 사용기간 단축

- 사용자 실수 이용

  - 사용자가 기억을 위해서 비밀번호를 적어 놓았을 경우,
    -> 공격자들 - 사회 공학 전술 등을 사용하여 사용자 혹은 관리자에게 성공적으로 비밀번호 획득 가능
  - 대응책: 사용자 훈련, 침입 탐지, 다른 인증 방법과 결합된 간단한 비밀번호 사용

- 다중 비밀번호 사용

  - 여러 네트워크 장치가 한 사용자에 대해 같은 비밀번호 혹은 비슷한 비밀번호를 사용
    -> 공격자 - 좀 더 효율적인 방법으로 피해를 줄 수 있음
  - 대응책: 각각의 네트워크 장치에서 같거나 혹은 비슷한 비밀번호 사용을 제한하는 정책 사용

- 컴퓨터 모니터링
  - 비밀번호가 네트워크 상에서 원격으로 교환된다면 도청에 취약
  - 간단한 비밀번호 암호화는 도청 및 재사용 때문에 문제 해결책이 될 수 없음
  - 대응책: 보다 강력한 비밀번호 암호화를 사용

### 해시 비밀번호의 사용

- UNIX 및 많은 운영체제에서 가장 널리 사용되는 비밀번호 기술
- 해시(Hash) 비밀번호와 솔트(salt) 값 사용
- 절차
  1. 사용자는 비밀번호를 선택하거나 부여 받음
  2. 비밀번호는 고정된 길이의 솔트값과 함께 조합
  3. 비밀번호와 솔트가 해시 알고리즘의 입력으로 제공되어 고정된 길이의 해시값을 생성
  4. 해시된 비밀번호는 솔트값과 같이 사용자 ID에 상응하는 비밀번호 파일에 저장
  5. 사용자가 UNIX 시스템에 접근을 시도할 때, 사용자는 ID와 비밀번호를 제공
  6. 운영체제는 제공된 ID를 비밀번호 파일의 색인으로 사용, 솔트와 비밀번호를 추출
  7. 솔트와 사용자가 제공한 비밀번호는 암호화 과정의 입력으로 사용
  8. 저장된 값과 일치하면 비밀번호 허용

### UNIX 비밀번호 방식

- 비밀 번호 검증

Password File (: User ID, Salt, Hash code)

User id -> (Select) = User ID

Salt + Password -> slow hash function + Hashed password -> Compare

- 솔트 사용의 목적

1. 비밀번호 파일에서 중복되는 비밀번호를 방지

- 만약 두 명의 사용자가 같은 비밀번호를 선택하더라도, 비밀번호들은 서로 다른 솔트 값을 할당 받으므로 두 명의 사용자의 해시된 배밀번호는 서로 다름

2. 오프라인 사전 공격을 획기적으로 어렵게 만듦

- 길이가 b비트인 솔트에 대해서 가능한 비밀번호이 수는 2^b가 되며, 사전 공격에서 비밀번호 추측의 어려움이 증가

3. 둘 혹은 그 이상의 시스템에서 한 사람에 의해 사용되는 같은 비밀번호를 발견하기는 거의 불가능

### 사용자 선택 비밀번호 크래킹

- 전통적 접근

  - 사전 공격

    - 가능한 비밀번호를 포함한 사전을 만들고 비밀번호 파일에 모두 시도
    - 각 비밀번호를 가능한 솔트 값들로 해시해서 저장된 해시 값과 비교하는 것
    - 찾아내지 못하면, 크래킹 프로그램은 사전 내의 모든 단어의 변형들에 대해서 시도함
    - 변형 - 역방향 철자, 숫자의 추가 또는 특수 기호, 문자의 순서성 등

  - rainbow table 공격

    - 미리 해시 값을 계산하여 저장해놓는 방법
    - 공격자가 가능한 한 많은 비밀번호를 가진 사전을 생성
    - 공격자는 각 비밀번호를 각각의 솔트 값과 관련해서 해시 값을 생성
    - 그 결과가 "rainbow table"이라 알려진 매머드급 해시테이블

  - 비밀번호 크래커

    - 사람들이 추측하기 용이한 비밀번호를 선택한다는 점을 이용
    - 어떤 사용자들은 비밀번호를 고를 때 아주 짧은 것을 선택
    - 간단한 해결책
      .시스템이 6자리 이하의 비밀번호를 거부
      .모든 비밀번호를 8자리로 고정

  - John the Ripper
    - 사전의 전체 단어를 시도해보는 공격에 많이 쓰임
    - 1996년 처음 개발된 오픈 소스 비밀번호 크래커 (패스워드 크래킹 소프트웨어 도구)

- 비밀번호 크래킹 기법의 발전

  - 두 가지 방향으로 향상

    - 1. 비밀번호 크래킹 처리 속도가 놀랍게 향상되었음
    - 2. 비밀번호 크래킹 기법은 잠재적 비밀번호 생성의 정교한 알고리즘을 사용

  - 복잡한 비밀번호 정책을 시행하는 대학교의 학생 2,500명의 비밀번호 분석
    - RockYou 등에서 유출된 실제 비밀번호 파일들을 데이터베이스로 구축
    - 그래프는 비밀번호당 추측 횟수에 따른 백분율을 나타냄
    - 10% 이상의 비밀번호는 10^10 번 추측으로 알아낼 수 있었음
    - 10^13번 추측으로는 40% 이상의 비밀번호를 알아냈음

### 비밀번호 파일 접근 제어

- 비밀번호 공격을 막기 위해 공격자의 비밀번호 파일에 대한 접근 거부

  - 특별한 권한 소유자만 파일의 해시된 비밀번호 접근이 가능
    - 공격자가 사용자의 비밀번호를 알지 못한다면 비밀번호 파일을 읽을 수 없음
    - 해시된 비밀번호는 사용자 ID와 격리되어 "Shadow password file" 역할

- 비밀번호 보호 정책

  - 기술을 바탕으로 한 완벽한 접근 제어 수단과 예측하기 어려운 사용자의 비밀번호 선택을 병행해야 함

- 비밀번호 파일의 취약점들
  - 대부분의 UNIX 시스템을 포함한 많은 시스템들은 예상치 못한 시스템 멈춤에 취약
  - 해커
    - 운영체제의 이러한 소프트웨어 취약점을 이용해 접근 제어 시스템을 우회하여 비밀번호 파일을 추출 가능
    - 파일 시스템 / 데이터베이스 관리 시스템의 취약점을 찾아 파일에 접근 가능
    - 보안 사고 -> 우발적으로 비밀번호 파일을 읽기와 계정의 손상이 발생 가능
    - 몇몇 사용자들은 다른 기억 영역에 다른 기기에 대한 계정을 가지고 있으며, 동일한 비밀번호를 사용함
    - 물리적 보안의 취약점은 해커에게 기회를 제공
    - 비밀번호를 여분의 디스크 또는 기록용 디스크에 위급 상황에 대비해 백업함
      - 이러한 백업을 공격자가 접근하여 비밀번호 파일 공격이 가능함
    - 사용자가 리눅스 같은 다른 OS로 부팅하여 비밀번호 파일에 접근할 수 있음
    - 시스템 비밀번호 파일 대신 네트워크 트래픽 스니핑 같은 다른 접근 방식으로 사용자의 ID와 비밀번호를 수집할 수 있음

### 비밀번호 선택 전략

- 사용자들이 무작위로 선택된 8개의 문자로 구성된 비밀번호를 부여 받는다면 비밀번호 크래킹은 매우 어려움

  - 대부분의 사용자들은 비밀번호를 기억하지 못함

- 목표: 사용자가 기억하기 쉬운 비밀번호를 선택하되 추측하기 쉬운 비밀번호 제거

- 기본적인 네 가지 기술

  - 사용자 교육
  - 컴퓨터에 의한 비밀번호 생성
  - 반응적 비밀번호 확인
  - 복잡한 비밀번호 정책

- 반응적 비밀번호 확인 전략

  - 시스템이 정기적으로 시스템 내부의 비밀번호 크래커를 작동시켜 추측 가능한 비밀번호를 시스템 자체적으로 발견
  - 시스템은 비밀번호가 추측 가능한 것이라면 사용자에게 이를 알리고 재설정 요구
  - 문제점
    - 1. 자원 소비가 큼
      - 비밀번호 파일을 훔칠 수 있는 공격자는 이러한 작업을 위해서 몇 시간 또는 심지어 며칠 동안 최대 CPU 시간을 투자할 수 있기 때문
    - 2. 비밀번호 반응 확인 시스템이 문제점을 발견하기 전까지 취약점이 계속 존재

- 사전적 비밀번호 정책
  - 비밀번호 보안을 향상하기 위한 가장 좋은 접근 방법
  - 사용자가 자신의 비밀번호를 선택할 때 `시스템 허락`을 받도록 하는 방식
  - 사용자에게 충분한 안내와 추측에 의한 사전 공격 가능성이 없는 비밀번호 중에서 사용자가 기억할 수 있는 비밀번호를 선택 유도

### 사전적 비밀번호 정책

- 비밀번호 크래커

  - 사용하지 않는 사전기반으로 암호를 재확인

- 규칙 적용

  - 암호가 준수해야 하는 특정 규칙

- Bloom filter
  - 해시를 사용한 사전 기반으로 테이블을 작성
  - 테이블에 대해 원하는 비밀번호 확인

## 3. 토큰 기반 인증

### 세션기반 인증 vs 토큰기반 인증

- 세션기반 인증

1. 로그인 (user ID & Password)
2. ID/PW 검증
3. 세션 저장
4. 세션 발급 (Set-Cookie: 세션 값)
5. 데이터 요청 (cookie: sessionId = 세션 값)
6. 세션 검증
7. 데이터 조회 및 반환
8. 데이터 응답

- 토큰기반 인증

1. 로그인 (user ID & Password)
2. ID/PW 검증
3. 토큰 전달
4. 데이터 요청 (Authorization: bearer token)
5. 토큰 유효성 검증
6. 데이터 조회 및 반환
7. 데이터 응답

### 토큰 기반 인증

- 토큰: 사용자 인증 목적을 위해 사용자가 소유한 객체

- 토큰으로 사용되는 카드 유형

| 카드 유형 | 특징 | 예 |
| 금형 도안 | 앞면 표지 | 구형 신용카드 |
| 전자기 띠 | 뒷면 전자기 띠, 앞면 문자 | 은행 카드 |
| 메모리 | 메모리 내장 | 선불 전화카드 |
| 스마트, 접촉형, 비접촉형 | 내부 메모리와 프로세서, 표면의 전기적 접촉, 내장된 라디오 안테나 | 생체 ID 카드 |

### 메모리 카드

- 데이터 저장 기능 (처리는 못 함)

  - 예) 뒷면에 전자기 띠 (마그네틱 라인)를 가진 은행 카드, 전자기 띠는 판독기가 읽을 수 있는 간단한 보안 코드만 저장

- 개인 식별 번호 (PIN) 또는 비밀번호와 결합하여 강력한 보안성을 제공

- 잠재적 약점
  - 특수 판독기 필요: 토큰 사용 비용과 판독기의 하드웨어 및 소프트웨어의 보안성 관리가 유지되어야 하는 필요성이 발생
  - 토큰 손실: 토큰을 잃어버린 경우 일시적으로 사용자의 시스템 접근이 제한
  - 토큰이 위조되거나 도용된다면, 공격자는 PIN만 알아내면 접근이 가능
  - 사용자 불만: 사용자가 ATM 사용을 위한 메모리 카드 사용에 어려움이 없더라도, 컴퓨터 접근을 위한 메모리 카드의 사용은 불편한 것으로 간주됨

### 스마트 카드

- 프로세서, 메모리, 입출력 포트를 포함한 전체 마이크로프로세서를 포함

- 스마트 카드

  - 1. 물리적 특징
    - 내장 마이크로 소프트웨어를 포함하고 있는 스마트 토큰, 은행 카드와 비슷한 스마트 토큰은 스마트카드라 불림
  - 2. 사용자 인터페이스
    - 사용자와 토큰 간의 인터페이스는 키패드와 화면이 포함됨
  - 3. 전자적 인터페이스
    - 스마트카드나 다른 토큰들은 호환되는 판독기/기록기와 통신을 위해서 전자적 인터페이스를 요구
    - 인터페이스 유형
      - 1. 접촉형
        - 표면을 스마트카드 판독기에 직접 접촉해야 함
        - 명령어, 데이터, 카드 상태 정보 등은 물리적 접촉면에서 발생
      - 2. 비접촉형
        - 스마트카드 판독기에 가까이 대기만 하면 됨
        - 판독기와 카드는 안테나를 가지고 있으며 라디오 주파수를 통해 교신
        - 대부분의 비접촉형 카드는 전자기적 신호에서 내부 칩을 위한 전원도 전달

- 스마트 토큰을 이용한 인증 프로토콜

1. 정적

- 사용자 - 자신을 토큰에 인증, 토큰 - 사용자를 컴퓨터에 인증

2. 동적 비밀번호 생성기

- 토큰 - 고유의 비밀번호를 주기적으로 생성
- 생성된 비밀번호 - 수동으로 사용자에 의해서 또는 토큰을 통해 인증을 위해 컴퓨터 시스템에 입력
- 토큰과 컴퓨터 시스템 - 초기화 및 동기화가 되어 컴퓨터가 현재 토큰의 비밀번호를 알고 있어야 함

3. 시도 응답

- 컴퓨터 시스템은 랜덤 숫자들로 이루어진 문장 생성
- 스마트 토큰 - 컴퓨터 시스템이 생성한 문장에 대한 응답을 생성

- 스마트 카드의 세 가지 메모리 타입

1. 읽기 전용 메모리 (ROM)

- 카드 번호와 카드 주인의 이름 정보 등이 사용 기간 동안 변하지 않고 저장 유지됨

2. 전기적으로 삭제가 가능하고 프로그래밍이 가능한 ROM (EEPROM)

- 프로토콜 같은 응용프로그램 데이터 및 프로그램만 저장함
- 매 시간 변화하는 데이터를 저장하기도 함
  Ex) 전화카드 안의 EEPROM은 통화 시간을 저장 및 유지함

3. RAM

- 응용프로그램이 실행되는 동안 일시적인 데이터를 저장함

### 스마트 카드/판독기 동작

스마트 카드 | 스마트 단말기

1. <- ATR
2. -> 프로토콜 협상 PTS
3. <- 협상 응답 PTS
4. -> 명령어 APDU
5. 응답 <- APDU

- APDU = Application protocol data unit
- ATR = Answer to reset
- PTS = Protocol type selection

### 전자식별카드

- 전자식별 카드
  - 국가 전자식별 카드(eID)는 운전면허증 같은 다른 국가 ID 카드처럼 정부나 상업적 용도로 사용될 수 있음
  - eID 카드는 다양한 프로그램에서 보다 강력한 신원 증명을 제공함
  - 최근에 개발되어 사용되는 독일의 neuerPersonalausweis: 표면에 인간이 판독할 수 있는 다음 데이터를 포함
    1. 개인 데이터
    - 이름, 생년월일, 주소: 여권과 운전면허증과 같은 형태
    2. 문서 번호
    - 9자리의 고유 카드 식별 문자열
    3. 카드 접근 번호 (CAN)
    - 6자리의 숫자가 표면에 인쇄됨
    - 비밀번호로 사용됨
    4. 기계 판독 영역 (MRZ)
    - 3줄의 인간과 기계가 판독할 수 있는 텍스트
    - 비밀번호로 사용 가능

### 전자 ID [eID]

- eID 기능

  1. ePass

  - 정부의 사용을 위한 기능, 카드 소유자의 신원을 나타내는 계수를 저장
  - 다른 서비스도 ePass를 사용할 수 있으며, ePass 기능은 카드에 구현되어야 함
  - 오프라인 기능

  2. eID

  - 다양한 정부와 상용 응용프로그램에서 일반적인 용도로 사용
  - 인가된 서비스가 카드 소유자의 허가 후 접근할 수 있는 신원 기록을 저장
  - 오프라인과 온라인 서비스에 모두 사용 가능

  3. eSign

  - 선택적 기능이며 개인키와 키를 검증하여 전자 서명을 생성하는 보증서를 저장

- 비밀번호 인증 연결 수립(PACE)
  - eID 카드 내의 비접촉형 RF 칩이 접근 제어 없이 판독되지 않도록 함
  - 온라인 응용프로그램의 경우: 카드 소유자만이 알고 있는 6자리의 PIN을 입력함으로써 접근이 수립
  - 오프라인 응용프로그램의 경우: 카드 뒷면에 인쇄된 MRZ 혹은 앞면에 인쇄된 6자리 카드 접근 번호가 사용

### eID 카드의 전자적 기능과 데이터

| 기능 | 목적 | PACE 비밀번호 | 데이터 | 사용 |
| ePass (의무) | 인가된 오프라인 검사 시스템이 데이터 판독 | CAN, MRZ | 얼굴 사진; 2개의 지문 (선택); MRZ 데이터 | 오프라인 생체 신원 검증을 정부 사용으로 예약 |
| eID (활성화 선택) | 온라인 응용프로그램의 데이터 판독 혹은 기능 접근 | eID PIN | 성; 예명 학위; 생년월일; 출생지; 주소; 커뮤니티 ID; 만료일 | 식별; 나이 검증; 커뮤니티 ID 검증; 제한적 식별(가명) 철회 요청 |
| eID (활성화 선택) | 오프라인 검사 시스템이 데이터를 판독하고 주소와 커뮤니티 ID를 업데이트 | CAN, MRZ | 성; 예명 학위; 생년월일; 출생지; 주소; 커뮤니티 ID; 만료일 | 식별; 나이 검증; 커뮤니티 ID 검증; 제한적 식별 (가명) 철회 요청 |
| eSign (증명 선택) | 인증 기관은 온라인으로 서명 보증 | eID PIN | 서명키; X.509 certificate | 전자 서명 생성 |
| eSign (증명 선택) | 시민은 eSign PIN으로 전자 서명 생성 | CAN | 서명키; X.509 certificate | 전자 서명 생성 |

- eID 사용자 인증

1. 사용자 요청 서비스 (예. 웹 브라우저)
2. 서비스 요청
3. eID 메세지 전송
4. 인증 요청
5. PIN 요청
6. 사용자 PIN 입력
7. 인증 프로토콜 진행
8. 인증 결과 전송
9. 인증 결과 전달
10. 서비스 허가
